use chrono::prelude::*;
use fxoanda_serdes::*;
use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// The granularity of a candlestick
#[derive(Debug, Serialize, Deserialize)]
pub enum CandlestickGranularity {
    #[serde(rename = "S5")]
    S5,
    #[serde(rename = "S10")]
    S10,
    #[serde(rename = "S15")]
    S15,
    #[serde(rename = "S30")]
    S30,
    #[serde(rename = "M1")]
    M1,
    #[serde(rename = "M2")]
    M2,
    #[serde(rename = "M4")]
    M4,
    #[serde(rename = "M5")]
    M5,
    #[serde(rename = "M10")]
    M10,
    #[serde(rename = "M15")]
    M15,
    #[serde(rename = "M30")]
    M30,
    #[serde(rename = "H1")]
    H1,
    #[serde(rename = "H2")]
    H2,
    #[serde(rename = "H3")]
    H3,
    #[serde(rename = "H4")]
    H4,
    #[serde(rename = "H6")]
    H6,
    #[serde(rename = "H8")]
    H8,
    #[serde(rename = "H12")]
    H12,
    #[serde(rename = "D")]
    D,
    #[serde(rename = "W")]
    W,
    #[serde(rename = "M")]
    M,
}

impl FromStr for CandlestickGranularity {
    type Err = ();
    fn from_str(s: &str) -> Result<CandlestickGranularity, ()> {
        match s {
            "S5" => Ok(CandlestickGranularity::S5),
            "S10" => Ok(CandlestickGranularity::S10),
            "S15" => Ok(CandlestickGranularity::S15),
            "S30" => Ok(CandlestickGranularity::S30),
            "M1" => Ok(CandlestickGranularity::M1),
            "M2" => Ok(CandlestickGranularity::M2),
            "M4" => Ok(CandlestickGranularity::M4),
            "M5" => Ok(CandlestickGranularity::M5),
            "M10" => Ok(CandlestickGranularity::M10),
            "M15" => Ok(CandlestickGranularity::M15),
            "M30" => Ok(CandlestickGranularity::M30),
            "H1" => Ok(CandlestickGranularity::H1),
            "H2" => Ok(CandlestickGranularity::H2),
            "H3" => Ok(CandlestickGranularity::H3),
            "H4" => Ok(CandlestickGranularity::H4),
            "H6" => Ok(CandlestickGranularity::H6),
            "H8" => Ok(CandlestickGranularity::H8),
            "H12" => Ok(CandlestickGranularity::H12),
            "D" => Ok(CandlestickGranularity::D),
            "W" => Ok(CandlestickGranularity::W),
            "M" => Ok(CandlestickGranularity::M),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for CandlestickGranularity {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The day of the week to use for candlestick granularities with weekly
/// alignment.
#[derive(Debug, Serialize, Deserialize)]
pub enum WeeklyAlignment {
    #[serde(rename = "Monday")]
    Monday,
    #[serde(rename = "Tuesday")]
    Tuesday,
    #[serde(rename = "Wednesday")]
    Wednesday,
    #[serde(rename = "Thursday")]
    Thursday,
    #[serde(rename = "Friday")]
    Friday,
    #[serde(rename = "Saturday")]
    Saturday,
    #[serde(rename = "Sunday")]
    Sunday,
}

impl FromStr for WeeklyAlignment {
    type Err = ();
    fn from_str(s: &str) -> Result<WeeklyAlignment, ()> {
        match s {
            "Monday" => Ok(WeeklyAlignment::Monday),
            "Tuesday" => Ok(WeeklyAlignment::Tuesday),
            "Wednesday" => Ok(WeeklyAlignment::Wednesday),
            "Thursday" => Ok(WeeklyAlignment::Thursday),
            "Friday" => Ok(WeeklyAlignment::Friday),
            "Saturday" => Ok(WeeklyAlignment::Saturday),
            "Sunday" => Ok(WeeklyAlignment::Sunday),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for WeeklyAlignment {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Candlestick {
    /// The start time of the candlestick
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    #[serde(default)]
    #[serde(rename = "bid", skip_serializing_if = "Option::is_none")]
    pub bid: Option<CandlestickData>,

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    #[serde(default)]
    #[serde(rename = "ask", skip_serializing_if = "Option::is_none")]
    pub ask: Option<CandlestickData>,

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    #[serde(default)]
    #[serde(rename = "mid", skip_serializing_if = "Option::is_none")]
    pub mid: Option<CandlestickData>,

    /// The number of prices created during the time-range represented by the
    /// candlestick.
    #[serde(default)]
    #[serde(rename = "volume", skip_serializing_if = "Option::is_none")]
    pub volume: Option<i32>,

    /// A flag indicating if the candlestick is complete. A complete
    /// candlestick is one whose ending time is not in the future.
    #[serde(default)]
    #[serde(rename = "complete", skip_serializing_if = "Option::is_none")]
    pub complete: Option<bool>,
}

impl Candlestick {
    pub fn new() -> Candlestick {
        Candlestick {
            time: None,
            bid: None,
            ask: None,
            mid: None,
            volume: None,
            complete: None,
        }
    }

    /// The start time of the candlestick
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Candlestick
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    /// - param CandlestickData
    /// - return Candlestick
    pub fn with_bid(mut self, x: CandlestickData) -> Self {
        self.bid = Some(x);
        self
    }

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    /// - param CandlestickData
    /// - return Candlestick
    pub fn with_ask(mut self, x: CandlestickData) -> Self {
        self.ask = Some(x);
        self
    }

    /// The price data (open, high, low, close) for the Candlestick
    /// representation.
    /// - param CandlestickData
    /// - return Candlestick
    pub fn with_mid(mut self, x: CandlestickData) -> Self {
        self.mid = Some(x);
        self
    }

    /// The number of prices created during the time-range represented by the
    /// candlestick.
    /// - param i32
    /// - return Candlestick
    pub fn with_volume(mut self, x: i32) -> Self {
        self.volume = Some(x);
        self
    }

    /// A flag indicating if the candlestick is complete. A complete
    /// candlestick is one whose ending time is not in the future.
    /// - param bool
    /// - return Candlestick
    pub fn with_complete(mut self, x: bool) -> Self {
        self.complete = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CandlestickData {
    /// The first (open) price in the time-range represented by the
    /// candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "o",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub o: Option<f32>,

    /// The highest price in the time-range represented by the candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "h",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub h: Option<f32>,

    /// The lowest price in the time-range represented by the candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "l",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub l: Option<f32>,

    /// The last (closing) price in the time-range represented by the
    /// candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "c",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub c: Option<f32>,
}

impl CandlestickData {
    pub fn new() -> CandlestickData {
        CandlestickData {
            o: None,
            h: None,
            l: None,
            c: None,
        }
    }

    /// The first (open) price in the time-range represented by the
    /// candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return CandlestickData
    pub fn with_o(mut self, x: f32) -> Self {
        self.o = Some(x);
        self
    }

    /// The highest price in the time-range represented by the candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return CandlestickData
    pub fn with_h(mut self, x: f32) -> Self {
        self.h = Some(x);
        self
    }

    /// The lowest price in the time-range represented by the candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return CandlestickData
    pub fn with_l(mut self, x: f32) -> Self {
        self.l = Some(x);
        self
    }

    /// The last (closing) price in the time-range represented by the
    /// candlestick.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return CandlestickData
    pub fn with_c(mut self, x: f32) -> Self {
        self.c = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderBook {
    /// The order book's instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The time when the order book snapshot was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The price (midpoint) for the order book's instrument at the time of
    /// the order book snapshot
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "bucketWidth",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub bucket_width: Option<f32>,

    /// The partitioned order book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    #[serde(default)]
    #[serde(rename = "buckets", skip_serializing_if = "Option::is_none")]
    pub buckets: Option<Vec<OrderBookBucket>>,
}

impl OrderBook {
    pub fn new() -> OrderBook {
        OrderBook {
            instrument: None,
            time: None,
            price: None,
            bucket_width: None,
            buckets: None,
        }
    }

    /// The order book's instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return OrderBook
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The time when the order book snapshot was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderBook
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The price (midpoint) for the order book's instrument at the time of
    /// the order book snapshot
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return OrderBook
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return OrderBook
    pub fn with_bucket_width(mut self, x: f32) -> Self {
        self.bucket_width = Some(x);
        self
    }

    /// The partitioned order book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    /// - param Vec<OrderBookBucket>
    /// - return OrderBook
    pub fn with_buckets(mut self, x: Vec<OrderBookBucket>) -> Self {
        self.buckets = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderBookBucket {
    /// The lowest price (inclusive) covered by the bucket. The bucket covers
    /// the price range from the price to price + the order book's
    /// bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The percentage of the total number of orders represented by the long
    /// orders found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "longCountPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub long_count_percent: Option<f32>,

    /// The percentage of the total number of orders represented by the short
    /// orders found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "shortCountPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub short_count_percent: Option<f32>,
}

impl OrderBookBucket {
    pub fn new() -> OrderBookBucket {
        OrderBookBucket {
            price: None,
            long_count_percent: None,
            short_count_percent: None,
        }
    }

    /// The lowest price (inclusive) covered by the bucket. The bucket covers
    /// the price range from the price to price + the order book's
    /// bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return OrderBookBucket
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The percentage of the total number of orders represented by the long
    /// orders found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return OrderBookBucket
    pub fn with_long_count_percent(mut self, x: f32) -> Self {
        self.long_count_percent = Some(x);
        self
    }

    /// The percentage of the total number of orders represented by the short
    /// orders found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return OrderBookBucket
    pub fn with_short_count_percent(mut self, x: f32) -> Self {
        self.short_count_percent = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PositionBook {
    /// The position book's instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The time when the position book snapshot was created
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The price (midpoint) for the position book's instrument at the time of
    /// the position book snapshot
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "bucketWidth",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub bucket_width: Option<f32>,

    /// The partitioned position book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    #[serde(default)]
    #[serde(rename = "buckets", skip_serializing_if = "Option::is_none")]
    pub buckets: Option<Vec<PositionBookBucket>>,
}

impl PositionBook {
    pub fn new() -> PositionBook {
        PositionBook {
            instrument: None,
            time: None,
            price: None,
            bucket_width: None,
            buckets: None,
        }
    }

    /// The position book's instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return PositionBook
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The time when the position book snapshot was created
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return PositionBook
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The price (midpoint) for the position book's instrument at the time of
    /// the position book snapshot
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return PositionBook
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return PositionBook
    pub fn with_bucket_width(mut self, x: f32) -> Self {
        self.bucket_width = Some(x);
        self
    }

    /// The partitioned position book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    /// - param Vec<PositionBookBucket>
    /// - return PositionBook
    pub fn with_buckets(mut self, x: Vec<PositionBookBucket>) -> Self {
        self.buckets = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PositionBookBucket {
    /// The lowest price (inclusive) covered by the bucket. The bucket covers
    /// the price range from the price to price + the position book's
    /// bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The percentage of the total number of positions represented by the
    /// long positions found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "longCountPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub long_count_percent: Option<f32>,

    /// The percentage of the total number of positions represented by the
    /// short positions found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "shortCountPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub short_count_percent: Option<f32>,
}

impl PositionBookBucket {
    pub fn new() -> PositionBookBucket {
        PositionBookBucket {
            price: None,
            long_count_percent: None,
            short_count_percent: None,
        }
    }

    /// The lowest price (inclusive) covered by the bucket. The bucket covers
    /// the price range from the price to price + the position book's
    /// bucketWidth.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return PositionBookBucket
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The percentage of the total number of positions represented by the
    /// long positions found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return PositionBookBucket
    pub fn with_long_count_percent(mut self, x: f32) -> Self {
        self.long_count_percent = Some(x);
        self
    }

    /// The percentage of the total number of positions represented by the
    /// short positions found in this bucket.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return PositionBookBucket
    pub fn with_short_count_percent(mut self, x: f32) -> Self {
        self.short_count_percent = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Position {
    /// The Position's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// Profit/loss realized by the Position over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "pl",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub pl: Option<f32>,

    /// The unrealized profit/loss of all open Trades that contribute to this
    /// Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// Margin currently used by the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// Profit/loss realized by the Position since the Account's resettablePL
    /// was last reset by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "resettablePL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub resettable_pl: Option<f32>,

    /// The total amount of financing paid/collected for this instrument over
    /// the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The total amount of commission paid for this instrument over the
    /// lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "commission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub commission: Option<f32>,

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFees",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fees: Option<f32>,

    /// The representation of a Position for a single direction (long or
    /// short).
    #[serde(default)]
    #[serde(rename = "long", skip_serializing_if = "Option::is_none")]
    pub long: Option<PositionSide>,

    /// The representation of a Position for a single direction (long or
    /// short).
    #[serde(default)]
    #[serde(rename = "short", skip_serializing_if = "Option::is_none")]
    pub short: Option<PositionSide>,
}

impl Position {
    pub fn new() -> Position {
        Position {
            instrument: None,
            pl: None,
            unrealized_pl: None,
            margin_used: None,
            resettable_pl: None,
            financing: None,
            commission: None,
            guaranteed_execution_fees: None,
            long: None,
            short: None,
        }
    }

    /// The Position's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return Position
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// Profit/loss realized by the Position over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_pl(mut self, x: f32) -> Self {
        self.pl = Some(x);
        self
    }

    /// The unrealized profit/loss of all open Trades that contribute to this
    /// Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// Margin currently used by the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// Profit/loss realized by the Position since the Account's resettablePL
    /// was last reset by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_resettable_pl(mut self, x: f32) -> Self {
        self.resettable_pl = Some(x);
        self
    }

    /// The total amount of financing paid/collected for this instrument over
    /// the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The total amount of commission paid for this instrument over the
    /// lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_commission(mut self, x: f32) -> Self {
        self.commission = Some(x);
        self
    }

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Position
    pub fn with_guaranteed_execution_fees(mut self, x: f32) -> Self {
        self.guaranteed_execution_fees = Some(x);
        self
    }

    /// The representation of a Position for a single direction (long or
    /// short).
    /// - param PositionSide
    /// - return Position
    pub fn with_long(mut self, x: PositionSide) -> Self {
        self.long = Some(x);
        self
    }

    /// The representation of a Position for a single direction (long or
    /// short).
    /// - param PositionSide
    /// - return Position
    pub fn with_short(mut self, x: PositionSide) -> Self {
        self.short = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PositionSide {
    /// Number of units in the position (negative value indicates short
    /// position, positive indicates long position).
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// Volume-weighted average of the underlying Trade open prices for the
    /// Position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "averagePrice",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub average_price: Option<f32>,

    /// List of the open Trade IDs which contribute to the open Position.
    #[serde(default)]
    #[serde(rename = "tradeIDs", skip_serializing_if = "Option::is_none")]
    pub trade_i_ds: Option<Vec<String>>,

    /// Profit/loss realized by the PositionSide over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "pl",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub pl: Option<f32>,

    /// The unrealized profit/loss of all open Trades that contribute to this
    /// PositionSide.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// Profit/loss realized by the PositionSide since the Account's
    /// resettablePL was last reset by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "resettablePL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub resettable_pl: Option<f32>,

    /// The total amount of financing paid/collected for this PositionSide
    /// over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders attached to Trades for
    /// this PositionSide.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFees",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fees: Option<f32>,
}

impl PositionSide {
    pub fn new() -> PositionSide {
        PositionSide {
            units: None,
            average_price: None,
            trade_i_ds: None,
            pl: None,
            unrealized_pl: None,
            resettable_pl: None,
            financing: None,
            guaranteed_execution_fees: None,
        }
    }

    /// Number of units in the position (negative value indicates short
    /// position, positive indicates long position).
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return PositionSide
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// Volume-weighted average of the underlying Trade open prices for the
    /// Position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return PositionSide
    pub fn with_average_price(mut self, x: f32) -> Self {
        self.average_price = Some(x);
        self
    }

    /// List of the open Trade IDs which contribute to the open Position.
    /// - param Vec<String>
    /// - return PositionSide
    pub fn with_trade_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_i_ds = Some(x);
        self
    }

    /// Profit/loss realized by the PositionSide over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionSide
    pub fn with_pl(mut self, x: f32) -> Self {
        self.pl = Some(x);
        self
    }

    /// The unrealized profit/loss of all open Trades that contribute to this
    /// PositionSide.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionSide
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// Profit/loss realized by the PositionSide since the Account's
    /// resettablePL was last reset by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionSide
    pub fn with_resettable_pl(mut self, x: f32) -> Self {
        self.resettable_pl = Some(x);
        self
    }

    /// The total amount of financing paid/collected for this PositionSide
    /// over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionSide
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders attached to Trades for
    /// this PositionSide.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionSide
    pub fn with_guaranteed_execution_fees(mut self, x: f32) -> Self {
        self.guaranteed_execution_fees = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculatedPositionState {
    /// The Position's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The Position's net unrealized profit/loss
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "netUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub net_unrealized_pl: Option<f32>,

    /// The unrealized profit/loss of the Position's long open Trades
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "longUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub long_unrealized_pl: Option<f32>,

    /// The unrealized profit/loss of the Position's short open Trades
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "shortUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub short_unrealized_pl: Option<f32>,

    /// Margin currently used by the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,
}

impl CalculatedPositionState {
    pub fn new() -> CalculatedPositionState {
        CalculatedPositionState {
            instrument: None,
            net_unrealized_pl: None,
            long_unrealized_pl: None,
            short_unrealized_pl: None,
            margin_used: None,
        }
    }

    /// The Position's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return CalculatedPositionState
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The Position's net unrealized profit/loss
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedPositionState
    pub fn with_net_unrealized_pl(mut self, x: f32) -> Self {
        self.net_unrealized_pl = Some(x);
        self
    }

    /// The unrealized profit/loss of the Position's long open Trades
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedPositionState
    pub fn with_long_unrealized_pl(mut self, x: f32) -> Self {
        self.long_unrealized_pl = Some(x);
        self
    }

    /// The unrealized profit/loss of the Position's short open Trades
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedPositionState
    pub fn with_short_unrealized_pl(mut self, x: f32) -> Self {
        self.short_unrealized_pl = Some(x);
        self
    }

    /// Margin currently used by the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedPositionState
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }
}

/// The current state of the Trade.
#[derive(Debug, Serialize, Deserialize)]
pub enum TradeState {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
    #[serde(rename = "CLOSE_WHEN_TRADEABLE")]
    CloseWhenTradeable,
}

impl FromStr for TradeState {
    type Err = ();
    fn from_str(s: &str) -> Result<TradeState, ()> {
        match s {
            "OPEN" => Ok(TradeState::Open),
            "CLOSED" => Ok(TradeState::Closed),
            "CLOSE_WHEN_TRADEABLE" => Ok(TradeState::CloseWhenTradeable),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TradeState {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The state to filter the Trades by
#[derive(Debug, Serialize, Deserialize)]
pub enum TradeStateFilter {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
    #[serde(rename = "CLOSE_WHEN_TRADEABLE")]
    CloseWhenTradeable,
    #[serde(rename = "ALL")]
    All,
}

impl FromStr for TradeStateFilter {
    type Err = ();
    fn from_str(s: &str) -> Result<TradeStateFilter, ()> {
        match s {
            "OPEN" => Ok(TradeStateFilter::Open),
            "CLOSED" => Ok(TradeStateFilter::Closed),
            "CLOSE_WHEN_TRADEABLE" => Ok(TradeStateFilter::CloseWhenTradeable),
            "ALL" => Ok(TradeStateFilter::All),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TradeStateFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Trade {
    /// The Trade's identifier, unique within the Trade's Account.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The Trade's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The execution price of the Trade.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The date/time when the Trade was opened.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "openTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub open_time: Option<DateTime<Utc>>,

    /// The current state of the Trade.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// The initial size of the Trade. Negative values indicate a short Trade,
    /// and positive values indicate a long Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "initialUnits",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_units: Option<f32>,

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "initialMarginRequired",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_margin_required: Option<f32>,

    /// The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "currentUnits",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub current_units: Option<f32>,

    /// The total profit/loss realized on the closed portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "realizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub realized_pl: Option<f32>,

    /// The unrealized profit/loss on the open portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// The average closing price of the Trade. Only present if the Trade has
    /// been closed or reduced at least once.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "averageClosePrice",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub average_close_price: Option<f32>,

    /// The IDs of the Transactions that have closed portions of this Trade.
    #[serde(default)]
    #[serde(
        rename = "closingTransactionIDs",
        skip_serializing_if = "Option::is_none"
    )]
    pub closing_transaction_i_ds: Option<Vec<String>>,

    /// The financing paid/collected for this Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "closeTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub close_time: Option<DateTime<Utc>>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// A TakeProfitOrder is an order that is linked to an open Trade and
    /// created with a price threshold. The Order will be filled (closing the
    /// Trade) by the first price that is equal to or better than the
    /// threshold. A TakeProfitOrder cannot be used to open a new Position.
    #[serde(default)]
    #[serde(rename = "takeProfitOrder", skip_serializing_if = "Option::is_none")]
    pub take_profit_order: Option<TakeProfitOrder>,

    /// A StopLossOrder is an order that is linked to an open Trade and
    /// created with a price threshold. The Order will be filled (closing the
    /// Trade) by the first price that is equal to or worse than the
    /// threshold. A StopLossOrder cannot be used to open a new Position.
    #[serde(default)]
    #[serde(rename = "stopLossOrder", skip_serializing_if = "Option::is_none")]
    pub stop_loss_order: Option<StopLossOrder>,

    /// A TrailingStopLossOrder is an order that is linked to an open Trade
    /// and created with a price distance. The price distance is used to
    /// calculate a trailing stop value for the order that is in the losing
    /// direction from the market price at the time of the order's creation.
    /// The trailing stop value will follow the market price as it moves in
    /// the winning direction, and the order will filled (closing the Trade)
    /// by the first price that is equal to or worse than the trailing stop
    /// value. A TrailingStopLossOrder cannot be used to open a new Position.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOrder",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order: Option<TrailingStopLossOrder>,
}

impl Trade {
    pub fn new() -> Trade {
        Trade {
            id: None,
            instrument: None,
            price: None,
            open_time: None,
            state: None,
            initial_units: None,
            initial_margin_required: None,
            current_units: None,
            realized_pl: None,
            unrealized_pl: None,
            margin_used: None,
            average_close_price: None,
            closing_transaction_i_ds: None,
            financing: None,
            close_time: None,
            client_extensions: None,
            take_profit_order: None,
            stop_loss_order: None,
            trailing_stop_loss_order: None,
        }
    }

    /// The Trade's identifier, unique within the Trade's Account.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return Trade
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The Trade's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return Trade
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The execution price of the Trade.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Trade
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The date/time when the Trade was opened.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Trade
    pub fn with_open_time(mut self, x: DateTime<Utc>) -> Self {
        self.open_time = Some(x);
        self
    }

    /// The current state of the Trade.
    /// - param String
    /// - return Trade
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// The initial size of the Trade. Negative values indicate a short Trade,
    /// and positive values indicate a long Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Trade
    pub fn with_initial_units(mut self, x: f32) -> Self {
        self.initial_units = Some(x);
        self
    }

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Trade
    pub fn with_initial_margin_required(mut self, x: f32) -> Self {
        self.initial_margin_required = Some(x);
        self
    }

    /// The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Trade
    pub fn with_current_units(mut self, x: f32) -> Self {
        self.current_units = Some(x);
        self
    }

    /// The total profit/loss realized on the closed portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Trade
    pub fn with_realized_pl(mut self, x: f32) -> Self {
        self.realized_pl = Some(x);
        self
    }

    /// The unrealized profit/loss on the open portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Trade
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Trade
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// The average closing price of the Trade. Only present if the Trade has
    /// been closed or reduced at least once.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Trade
    pub fn with_average_close_price(mut self, x: f32) -> Self {
        self.average_close_price = Some(x);
        self
    }

    /// The IDs of the Transactions that have closed portions of this Trade.
    /// - param Vec<String>
    /// - return Trade
    pub fn with_closing_transaction_i_ds(mut self, x: Vec<String>) -> Self {
        self.closing_transaction_i_ds = Some(x);
        self
    }

    /// The financing paid/collected for this Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Trade
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Trade
    pub fn with_close_time(mut self, x: DateTime<Utc>) -> Self {
        self.close_time = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return Trade
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// A TakeProfitOrder is an order that is linked to an open Trade and
    /// created with a price threshold. The Order will be filled (closing the
    /// Trade) by the first price that is equal to or better than the
    /// threshold. A TakeProfitOrder cannot be used to open a new Position.
    /// - param TakeProfitOrder
    /// - return Trade
    pub fn with_take_profit_order(mut self, x: TakeProfitOrder) -> Self {
        self.take_profit_order = Some(x);
        self
    }

    /// A StopLossOrder is an order that is linked to an open Trade and
    /// created with a price threshold. The Order will be filled (closing the
    /// Trade) by the first price that is equal to or worse than the
    /// threshold. A StopLossOrder cannot be used to open a new Position.
    /// - param StopLossOrder
    /// - return Trade
    pub fn with_stop_loss_order(mut self, x: StopLossOrder) -> Self {
        self.stop_loss_order = Some(x);
        self
    }

    /// A TrailingStopLossOrder is an order that is linked to an open Trade
    /// and created with a price distance. The price distance is used to
    /// calculate a trailing stop value for the order that is in the losing
    /// direction from the market price at the time of the order's creation.
    /// The trailing stop value will follow the market price as it moves in
    /// the winning direction, and the order will filled (closing the Trade)
    /// by the first price that is equal to or worse than the trailing stop
    /// value. A TrailingStopLossOrder cannot be used to open a new Position.
    /// - param TrailingStopLossOrder
    /// - return Trade
    pub fn with_trailing_stop_loss_order(mut self, x: TrailingStopLossOrder) -> Self {
        self.trailing_stop_loss_order = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeSummary {
    /// The Trade's identifier, unique within the Trade's Account.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The Trade's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The execution price of the Trade.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The date/time when the Trade was opened.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "openTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub open_time: Option<DateTime<Utc>>,

    /// The current state of the Trade.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// The initial size of the Trade. Negative values indicate a short Trade,
    /// and positive values indicate a long Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "initialUnits",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_units: Option<f32>,

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "initialMarginRequired",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_margin_required: Option<f32>,

    /// The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "currentUnits",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub current_units: Option<f32>,

    /// The total profit/loss realized on the closed portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "realizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub realized_pl: Option<f32>,

    /// The unrealized profit/loss on the open portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// The average closing price of the Trade. Only present if the Trade has
    /// been closed or reduced at least once.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "averageClosePrice",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub average_close_price: Option<f32>,

    /// The IDs of the Transactions that have closed portions of this Trade.
    #[serde(default)]
    #[serde(
        rename = "closingTransactionIDs",
        skip_serializing_if = "Option::is_none"
    )]
    pub closing_transaction_i_ds: Option<Vec<String>>,

    /// The financing paid/collected for this Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "closeTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub close_time: Option<DateTime<Utc>>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// ID of the Trade's Take Profit Order, only provided if such an Order
    /// exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "takeProfitOrderID", skip_serializing_if = "Option::is_none")]
    pub take_profit_order_id: Option<String>,

    /// ID of the Trade's Stop Loss Order, only provided if such an Order
    /// exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "stopLossOrderID", skip_serializing_if = "Option::is_none")]
    pub stop_loss_order_id: Option<String>,

    /// ID of the Trade's Trailing Stop Loss Order, only provided if such an
    /// Order exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order_id: Option<String>,
}

impl TradeSummary {
    pub fn new() -> TradeSummary {
        TradeSummary {
            id: None,
            instrument: None,
            price: None,
            open_time: None,
            state: None,
            initial_units: None,
            initial_margin_required: None,
            current_units: None,
            realized_pl: None,
            unrealized_pl: None,
            margin_used: None,
            average_close_price: None,
            closing_transaction_i_ds: None,
            financing: None,
            close_time: None,
            client_extensions: None,
            take_profit_order_id: None,
            stop_loss_order_id: None,
            trailing_stop_loss_order_id: None,
        }
    }

    /// The Trade's identifier, unique within the Trade's Account.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TradeSummary
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The Trade's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return TradeSummary
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The execution price of the Trade.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TradeSummary
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The date/time when the Trade was opened.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TradeSummary
    pub fn with_open_time(mut self, x: DateTime<Utc>) -> Self {
        self.open_time = Some(x);
        self
    }

    /// The current state of the Trade.
    /// - param String
    /// - return TradeSummary
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// The initial size of the Trade. Negative values indicate a short Trade,
    /// and positive values indicate a long Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TradeSummary
    pub fn with_initial_units(mut self, x: f32) -> Self {
        self.initial_units = Some(x);
        self
    }

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeSummary
    pub fn with_initial_margin_required(mut self, x: f32) -> Self {
        self.initial_margin_required = Some(x);
        self
    }

    /// The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TradeSummary
    pub fn with_current_units(mut self, x: f32) -> Self {
        self.current_units = Some(x);
        self
    }

    /// The total profit/loss realized on the closed portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeSummary
    pub fn with_realized_pl(mut self, x: f32) -> Self {
        self.realized_pl = Some(x);
        self
    }

    /// The unrealized profit/loss on the open portion of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeSummary
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeSummary
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// The average closing price of the Trade. Only present if the Trade has
    /// been closed or reduced at least once.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TradeSummary
    pub fn with_average_close_price(mut self, x: f32) -> Self {
        self.average_close_price = Some(x);
        self
    }

    /// The IDs of the Transactions that have closed portions of this Trade.
    /// - param Vec<String>
    /// - return TradeSummary
    pub fn with_closing_transaction_i_ds(mut self, x: Vec<String>) -> Self {
        self.closing_transaction_i_ds = Some(x);
        self
    }

    /// The financing paid/collected for this Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeSummary
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TradeSummary
    pub fn with_close_time(mut self, x: DateTime<Utc>) -> Self {
        self.close_time = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TradeSummary
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// ID of the Trade's Take Profit Order, only provided if such an Order
    /// exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TradeSummary
    pub fn with_take_profit_order_id(mut self, x: String) -> Self {
        self.take_profit_order_id = Some(x);
        self
    }

    /// ID of the Trade's Stop Loss Order, only provided if such an Order
    /// exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TradeSummary
    pub fn with_stop_loss_order_id(mut self, x: String) -> Self {
        self.stop_loss_order_id = Some(x);
        self
    }

    /// ID of the Trade's Trailing Stop Loss Order, only provided if such an
    /// Order exists.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TradeSummary
    pub fn with_trailing_stop_loss_order_id(mut self, x: String) -> Self {
        self.trailing_stop_loss_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculatedTradeState {
    /// The Trade's ID.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The Trade's unrealized profit/loss.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,
}

impl CalculatedTradeState {
    pub fn new() -> CalculatedTradeState {
        CalculatedTradeState {
            id: None,
            unrealized_pl: None,
            margin_used: None,
        }
    }

    /// The Trade's ID.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return CalculatedTradeState
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The Trade's unrealized profit/loss.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedTradeState
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// Margin currently used by the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedTradeState
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }
}

/// The classification of TradePLs.
#[derive(Debug, Serialize, Deserialize)]
pub enum TradePL {
    #[serde(rename = "POSITIVE")]
    Positive,
    #[serde(rename = "NEGATIVE")]
    Negative,
    #[serde(rename = "ZERO")]
    Zero,
}

impl FromStr for TradePL {
    type Err = ();
    fn from_str(s: &str) -> Result<TradePL, ()> {
        match s {
            "POSITIVE" => Ok(TradePL::Positive),
            "NEGATIVE" => Ok(TradePL::Negative),
            "ZERO" => Ok(TradePL::Zero),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TradePL {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MT4TransactionHeartbeat {
    /// The string "HEARTBEAT"
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The date/time when the TransactionHeartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,
}

impl MT4TransactionHeartbeat {
    pub fn new() -> MT4TransactionHeartbeat {
        MT4TransactionHeartbeat {
            otype: None,
            time: None,
        }
    }

    /// The string "HEARTBEAT"
    /// - param String
    /// - return MT4TransactionHeartbeat
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The date/time when the TransactionHeartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MT4TransactionHeartbeat
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }
}

/// The type of an Instrument.
#[derive(Debug, Serialize, Deserialize)]
pub enum InstrumentType {
    #[serde(rename = "CURRENCY")]
    Currency,
    #[serde(rename = "CFD")]
    Cfd,
    #[serde(rename = "METAL")]
    Metal,
}

impl FromStr for InstrumentType {
    type Err = ();
    fn from_str(s: &str) -> Result<InstrumentType, ()> {
        match s {
            "CURRENCY" => Ok(InstrumentType::Currency),
            "CFD" => Ok(InstrumentType::Cfd),
            "METAL" => Ok(InstrumentType::Metal),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for InstrumentType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Instrument {
    /// The name of the Instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The type of the Instrument
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The display name of the Instrument
    #[serde(default)]
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,

    /// The location of the "pip" for this instrument. The decimal position of
    /// the pip in this Instrument's price can be found at 10 ^ pipLocation
    /// (e.g. -4 pipLocation results in a decimal pip position of 10 ^ -4 =
    /// 0.0001).
    #[serde(default)]
    #[serde(rename = "pipLocation", skip_serializing_if = "Option::is_none")]
    pub pip_location: Option<i32>,

    /// The number of decimal places that should be used to display prices for
    /// this instrument. (e.g. a displayPrecision of 5 would result in a price
    /// of "1" being displayed as "1.00000")
    #[serde(default)]
    #[serde(rename = "displayPrecision", skip_serializing_if = "Option::is_none")]
    pub display_precision: Option<i32>,

    /// The amount of decimal places that may be provided when specifying the
    /// number of units traded for this instrument.
    #[serde(default)]
    #[serde(
        rename = "tradeUnitsPrecision",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_units_precision: Option<i32>,

    /// The smallest number of units allowed to be traded for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "minimumTradeSize",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub minimum_trade_size: Option<f32>,

    /// The maximum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "maximumTrailingStopDistance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub maximum_trailing_stop_distance: Option<f32>,

    /// The minimum distance allowed between the Trade’s fill price and the
    /// configured price for guaranteed Stop Loss Orders created for this
    /// instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "minimumGuaranteedStopLossDistance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub minimum_guaranteed_stop_loss_distance: Option<f32>,

    /// The minimum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "minimumTrailingStopDistance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub minimum_trailing_stop_distance: Option<f32>,

    /// The maximum position size allowed for this instrument. Specified in
    /// units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "maximumPositionSize",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub maximum_position_size: Option<f32>,

    /// The maximum units allowed for an Order placed for this instrument.
    /// Specified in units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "maximumOrderUnits",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub maximum_order_units: Option<f32>,

    /// The margin rate for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_rate: Option<f32>,

    /// An InstrumentCommission represents an instrument-specific commission
    #[serde(default)]
    #[serde(rename = "commission", skip_serializing_if = "Option::is_none")]
    pub commission: Option<InstrumentCommission>,

    /// The overall behaviour of the Account regarding Guaranteed Stop Loss
    /// Orders for a specific Instrument.
    #[serde(default)]
    #[serde(
        rename = "guaranteedStopLossOrderMode",
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_mode: Option<String>,

    /// The amount that is charged to the account if a guaranteed Stop Loss
    /// Order is triggered and filled. The value is in price units and is
    /// charged for each unit of the Trade. This field will only be present if
    /// the Account’s guaranteedStopLossOrderMode for this Instrument is not
    /// ‘DISABLED’.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "guaranteedStopLossOrderExecutionPremium",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_stop_loss_order_execution_premium: Option<f32>,

    /// A GuaranteedStopLossOrderLevelRestriction represents the total
    /// position size that can exist within a given price window for Trades
    /// with guaranteed Stop Loss Orders attached for a specific Instrument.
    #[serde(default)]
    #[serde(
        rename = "guaranteedStopLossOrderLevelRestriction",
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_level_restriction:
        Option<GuaranteedStopLossOrderLevelRestriction>,

    /// Financing data for this instrument.
    #[serde(default)]
    #[serde(rename = "financing", skip_serializing_if = "Option::is_none")]
    pub financing: Option<InstrumentFinancing>,

    /// The tags associated with this instrument.
    #[serde(default)]
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

impl Instrument {
    pub fn new() -> Instrument {
        Instrument {
            name: None,
            otype: None,
            display_name: None,
            pip_location: None,
            display_precision: None,
            trade_units_precision: None,
            minimum_trade_size: None,
            maximum_trailing_stop_distance: None,
            minimum_guaranteed_stop_loss_distance: None,
            minimum_trailing_stop_distance: None,
            maximum_position_size: None,
            maximum_order_units: None,
            margin_rate: None,
            commission: None,
            guaranteed_stop_loss_order_mode: None,
            guaranteed_stop_loss_order_execution_premium: None,
            guaranteed_stop_loss_order_level_restriction: None,
            financing: None,
            tags: None,
        }
    }

    /// The name of the Instrument
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return Instrument
    pub fn with_name(mut self, x: String) -> Self {
        self.name = Some(x);
        self
    }

    /// The type of the Instrument
    /// - param String
    /// - return Instrument
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The display name of the Instrument
    /// - param String
    /// - return Instrument
    pub fn with_display_name(mut self, x: String) -> Self {
        self.display_name = Some(x);
        self
    }

    /// The location of the "pip" for this instrument. The decimal position of
    /// the pip in this Instrument's price can be found at 10 ^ pipLocation
    /// (e.g. -4 pipLocation results in a decimal pip position of 10 ^ -4 =
    /// 0.0001).
    /// - param i32
    /// - return Instrument
    pub fn with_pip_location(mut self, x: i32) -> Self {
        self.pip_location = Some(x);
        self
    }

    /// The number of decimal places that should be used to display prices for
    /// this instrument. (e.g. a displayPrecision of 5 would result in a price
    /// of "1" being displayed as "1.00000")
    /// - param i32
    /// - return Instrument
    pub fn with_display_precision(mut self, x: i32) -> Self {
        self.display_precision = Some(x);
        self
    }

    /// The amount of decimal places that may be provided when specifying the
    /// number of units traded for this instrument.
    /// - param i32
    /// - return Instrument
    pub fn with_trade_units_precision(mut self, x: i32) -> Self {
        self.trade_units_precision = Some(x);
        self
    }

    /// The smallest number of units allowed to be traded for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_minimum_trade_size(mut self, x: f32) -> Self {
        self.minimum_trade_size = Some(x);
        self
    }

    /// The maximum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_maximum_trailing_stop_distance(mut self, x: f32) -> Self {
        self.maximum_trailing_stop_distance = Some(x);
        self
    }

    /// The minimum distance allowed between the Trade’s fill price and the
    /// configured price for guaranteed Stop Loss Orders created for this
    /// instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_minimum_guaranteed_stop_loss_distance(mut self, x: f32) -> Self {
        self.minimum_guaranteed_stop_loss_distance = Some(x);
        self
    }

    /// The minimum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_minimum_trailing_stop_distance(mut self, x: f32) -> Self {
        self.minimum_trailing_stop_distance = Some(x);
        self
    }

    /// The maximum position size allowed for this instrument. Specified in
    /// units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_maximum_position_size(mut self, x: f32) -> Self {
        self.maximum_position_size = Some(x);
        self
    }

    /// The maximum units allowed for an Order placed for this instrument.
    /// Specified in units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_maximum_order_units(mut self, x: f32) -> Self {
        self.maximum_order_units = Some(x);
        self
    }

    /// The margin rate for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_margin_rate(mut self, x: f32) -> Self {
        self.margin_rate = Some(x);
        self
    }

    /// An InstrumentCommission represents an instrument-specific commission
    /// - param InstrumentCommission
    /// - return Instrument
    pub fn with_commission(mut self, x: InstrumentCommission) -> Self {
        self.commission = Some(x);
        self
    }

    /// The overall behaviour of the Account regarding Guaranteed Stop Loss
    /// Orders for a specific Instrument.
    /// - param String
    /// - return Instrument
    pub fn with_guaranteed_stop_loss_order_mode(mut self, x: String) -> Self {
        self.guaranteed_stop_loss_order_mode = Some(x);
        self
    }

    /// The amount that is charged to the account if a guaranteed Stop Loss
    /// Order is triggered and filled. The value is in price units and is
    /// charged for each unit of the Trade. This field will only be present if
    /// the Account’s guaranteedStopLossOrderMode for this Instrument is not
    /// ‘DISABLED’.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Instrument
    pub fn with_guaranteed_stop_loss_order_execution_premium(mut self, x: f32) -> Self {
        self.guaranteed_stop_loss_order_execution_premium = Some(x);
        self
    }

    /// A GuaranteedStopLossOrderLevelRestriction represents the total
    /// position size that can exist within a given price window for Trades
    /// with guaranteed Stop Loss Orders attached for a specific Instrument.
    /// - param GuaranteedStopLossOrderLevelRestriction
    /// - return Instrument
    pub fn with_guaranteed_stop_loss_order_level_restriction(
        mut self,
        x: GuaranteedStopLossOrderLevelRestriction,
    ) -> Self {
        self.guaranteed_stop_loss_order_level_restriction = Some(x);
        self
    }

    /// Financing data for this instrument.
    /// - param InstrumentFinancing
    /// - return Instrument
    pub fn with_financing(mut self, x: InstrumentFinancing) -> Self {
        self.financing = Some(x);
        self
    }

    /// The tags associated with this instrument.
    /// - param Vec<Tag>
    /// - return Instrument
    pub fn with_tags(mut self, x: Vec<Tag>) -> Self {
        self.tags = Some(x);
        self
    }
}

/// DateTime header
#[derive(Debug, Serialize, Deserialize)]
pub enum AcceptDatetimeFormat {
    #[serde(rename = "UNIX")]
    Unix,
    #[serde(rename = "RFC3339")]
    Rfc3339,
}

impl FromStr for AcceptDatetimeFormat {
    type Err = ();
    fn from_str(s: &str) -> Result<AcceptDatetimeFormat, ()> {
        match s {
            "UNIX" => Ok(AcceptDatetimeFormat::Unix),
            "RFC3339" => Ok(AcceptDatetimeFormat::Rfc3339),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for AcceptDatetimeFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct InstrumentCommission {
    /// The commission amount (in the Account's home currency) charged per
    /// unitsTraded of the instrument
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "commission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub commission: Option<f32>,

    /// The number of units traded that the commission amount is based on.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "unitsTraded",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units_traded: Option<f32>,

    /// The minimum commission amount (in the Account's home currency) that is
    /// charged when an Order is filled for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "minimumCommission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub minimum_commission: Option<f32>,
}

impl InstrumentCommission {
    pub fn new() -> InstrumentCommission {
        InstrumentCommission {
            commission: None,
            units_traded: None,
            minimum_commission: None,
        }
    }

    /// The commission amount (in the Account's home currency) charged per
    /// unitsTraded of the instrument
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return InstrumentCommission
    pub fn with_commission(mut self, x: f32) -> Self {
        self.commission = Some(x);
        self
    }

    /// The number of units traded that the commission amount is based on.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return InstrumentCommission
    pub fn with_units_traded(mut self, x: f32) -> Self {
        self.units_traded = Some(x);
        self
    }

    /// The minimum commission amount (in the Account's home currency) that is
    /// charged when an Order is filled for this instrument.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return InstrumentCommission
    pub fn with_minimum_commission(mut self, x: f32) -> Self {
        self.minimum_commission = Some(x);
        self
    }
}

/// The overall behaviour of the Account regarding Guaranteed Stop Loss
/// Orders for a specific Instrument.
#[derive(Debug, Serialize, Deserialize)]
pub enum GuaranteedStopLossOrderModeForInstrument {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "ALLOWED")]
    Allowed,
    #[serde(rename = "REQUIRED")]
    Required,
}

impl FromStr for GuaranteedStopLossOrderModeForInstrument {
    type Err = ();
    fn from_str(s: &str) -> Result<GuaranteedStopLossOrderModeForInstrument, ()> {
        match s {
            "DISABLED" => Ok(GuaranteedStopLossOrderModeForInstrument::Disabled),
            "ALLOWED" => Ok(GuaranteedStopLossOrderModeForInstrument::Allowed),
            "REQUIRED" => Ok(GuaranteedStopLossOrderModeForInstrument::Required),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for GuaranteedStopLossOrderModeForInstrument {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct InstrumentFinancing {
    /// The financing rate to be used for a long position for the instrument.
    /// The value is in decimal rather than percentage points, i.e. 5% is
    /// represented as 0.05.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "longRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub long_rate: Option<f32>,

    /// The financing rate to be used for a short position for the instrument.
    /// The value is in decimal rather than percentage points, i.e. 5% is
    /// represented as 0.05.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "shortRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub short_rate: Option<f32>,

    /// The days of the week to debit or credit financing charges; the exact
    /// time of day at which to charge the financing is set in the
    /// DivisionTradingGroup for the client’s account.
    #[serde(default)]
    #[serde(
        rename = "financingDaysOfWeek",
        skip_serializing_if = "Option::is_none"
    )]
    pub financing_days_of_week: Option<Vec<FinancingDayOfWeek>>,
}

impl InstrumentFinancing {
    pub fn new() -> InstrumentFinancing {
        InstrumentFinancing {
            long_rate: None,
            short_rate: None,
            financing_days_of_week: None,
        }
    }

    /// The financing rate to be used for a long position for the instrument.
    /// The value is in decimal rather than percentage points, i.e. 5% is
    /// represented as 0.05.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return InstrumentFinancing
    pub fn with_long_rate(mut self, x: f32) -> Self {
        self.long_rate = Some(x);
        self
    }

    /// The financing rate to be used for a short position for the instrument.
    /// The value is in decimal rather than percentage points, i.e. 5% is
    /// represented as 0.05.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return InstrumentFinancing
    pub fn with_short_rate(mut self, x: f32) -> Self {
        self.short_rate = Some(x);
        self
    }

    /// The days of the week to debit or credit financing charges; the exact
    /// time of day at which to charge the financing is set in the
    /// DivisionTradingGroup for the client’s account.
    /// - param Vec<FinancingDayOfWeek>
    /// - return InstrumentFinancing
    pub fn with_financing_days_of_week(mut self, x: Vec<FinancingDayOfWeek>) -> Self {
        self.financing_days_of_week = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Tag {
    /// The type of the tag.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The name of the tag.
    #[serde(default)]
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl Tag {
    pub fn new() -> Tag {
        Tag {
            otype: None,
            name: None,
        }
    }

    /// The type of the tag.
    /// - param String
    /// - return Tag
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The name of the tag.
    /// - param String
    /// - return Tag
    pub fn with_name(mut self, x: String) -> Self {
        self.name = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FinancingDayOfWeek {
    /// The DayOfWeek provides a representation of the day of the week.
    #[serde(default)]
    #[serde(rename = "dayOfWeek", skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,

    /// The number of days worth of financing to be charged on dayOfWeek.
    #[serde(default)]
    #[serde(rename = "daysCharged", skip_serializing_if = "Option::is_none")]
    pub days_charged: Option<i32>,
}

impl FinancingDayOfWeek {
    pub fn new() -> FinancingDayOfWeek {
        FinancingDayOfWeek {
            day_of_week: None,
            days_charged: None,
        }
    }

    /// The DayOfWeek provides a representation of the day of the week.
    /// - param String
    /// - return FinancingDayOfWeek
    pub fn with_day_of_week(mut self, x: String) -> Self {
        self.day_of_week = Some(x);
        self
    }

    /// The number of days worth of financing to be charged on dayOfWeek.
    /// - param i32
    /// - return FinancingDayOfWeek
    pub fn with_days_charged(mut self, x: i32) -> Self {
        self.days_charged = Some(x);
        self
    }
}

/// The DayOfWeek provides a representation of the day of the week.
#[derive(Debug, Serialize, Deserialize)]
pub enum DayOfWeek {
    #[serde(rename = "SUNDAY")]
    Sunday,
    #[serde(rename = "MONDAY")]
    Monday,
    #[serde(rename = "TUESDAY")]
    Tuesday,
    #[serde(rename = "WEDNESDAY")]
    Wednesday,
    #[serde(rename = "THURSDAY")]
    Thursday,
    #[serde(rename = "FRIDAY")]
    Friday,
    #[serde(rename = "SATURDAY")]
    Saturday,
}

impl FromStr for DayOfWeek {
    type Err = ();
    fn from_str(s: &str) -> Result<DayOfWeek, ()> {
        match s {
            "SUNDAY" => Ok(DayOfWeek::Sunday),
            "MONDAY" => Ok(DayOfWeek::Monday),
            "TUESDAY" => Ok(DayOfWeek::Tuesday),
            "WEDNESDAY" => Ok(DayOfWeek::Wednesday),
            "THURSDAY" => Ok(DayOfWeek::Thursday),
            "FRIDAY" => Ok(DayOfWeek::Friday),
            "SATURDAY" => Ok(DayOfWeek::Saturday),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for DayOfWeek {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GuaranteedStopLossOrderLevelRestriction {
    /// Applies to Trades with a guaranteed Stop Loss Order attached for the
    /// specified Instrument. This is the total allowed Trade volume that can
    /// exist within the priceRange based on the trigger prices of the
    /// guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "volume",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub volume: Option<f32>,

    /// The price range the volume applies to. This value is in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "priceRange",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_range: Option<f32>,
}

impl GuaranteedStopLossOrderLevelRestriction {
    pub fn new() -> GuaranteedStopLossOrderLevelRestriction {
        GuaranteedStopLossOrderLevelRestriction {
            volume: None,
            price_range: None,
        }
    }

    /// Applies to Trades with a guaranteed Stop Loss Order attached for the
    /// specified Instrument. This is the total allowed Trade volume that can
    /// exist within the priceRange based on the trigger prices of the
    /// guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return GuaranteedStopLossOrderLevelRestriction
    pub fn with_volume(mut self, x: f32) -> Self {
        self.volume = Some(x);
        self
    }

    /// The price range the volume applies to. This value is in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return GuaranteedStopLossOrderLevelRestriction
    pub fn with_price_range(mut self, x: f32) -> Self {
        self.price_range = Some(x);
        self
    }
}

/// In the context of an Order or a Trade, defines whether the units are
/// positive or negative.
#[derive(Debug, Serialize, Deserialize)]
pub enum Direction {
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl FromStr for Direction {
    type Err = ();
    fn from_str(s: &str) -> Result<Direction, ()> {
        match s {
            "LONG" => Ok(Direction::Long),
            "SHORT" => Ok(Direction::Short),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for Direction {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Account {
    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    #[serde(default)]
    #[serde(rename = "alias", skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    #[serde(default)]
    #[serde(rename = "currency", skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,

    /// The current balance of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "balance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub balance: Option<f32>,

    /// ID of the user that created the Account.
    #[serde(default)]
    #[serde(rename = "createdByUserID", skip_serializing_if = "Option::is_none")]
    pub created_by_user_id: Option<i32>,

    /// The date/time when the Account was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub created_time: Option<DateTime<Utc>>,

    /// The current guaranteed Stop Loss Order mode of the Account.
    #[serde(default)]
    #[serde(
        rename = "guaranteedStopLossOrderMode",
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_mode: Option<String>,

    /// The total profit/loss realized over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "pl",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub pl: Option<f32>,

    /// The total realized profit/loss for the Account since it was last reset
    /// by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "resettablePL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub resettable_pl: Option<f32>,

    /// The date/time that the Account's resettablePL was last reset.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "resettablePLTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub resettable_pl_time: Option<DateTime<Utc>>,

    /// The total amount of financing paid/collected over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The total amount of commission paid over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "commission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub commission: Option<f32>,

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFees",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fees: Option<f32>,

    /// Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided if
    /// a margin rate override exists for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_rate: Option<f32>,

    /// The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "marginCallEnterTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub margin_call_enter_time: Option<DateTime<Utc>>,

    /// The number of times that the Account's current margin call was
    /// extended.
    #[serde(default)]
    #[serde(
        rename = "marginCallExtensionCount",
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_extension_count: Option<i32>,

    /// The date/time of the Account's last margin call extension.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "lastMarginCallExtensionTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub last_margin_call_extension_time: Option<DateTime<Utc>>,

    /// The number of Trades currently open in the Account.
    #[serde(default)]
    #[serde(rename = "openTradeCount", skip_serializing_if = "Option::is_none")]
    pub open_trade_count: Option<i32>,

    /// The number of Positions currently open in the Account.
    #[serde(default)]
    #[serde(rename = "openPositionCount", skip_serializing_if = "Option::is_none")]
    pub open_position_count: Option<i32>,

    /// The number of Orders currently pending in the Account.
    #[serde(default)]
    #[serde(rename = "pendingOrderCount", skip_serializing_if = "Option::is_none")]
    pub pending_order_count: Option<i32>,

    /// Flag indicating that the Account has hedging enabled.
    #[serde(default)]
    #[serde(rename = "hedgingEnabled", skip_serializing_if = "Option::is_none")]
    pub hedging_enabled: Option<bool>,

    /// The date/time of the last order that was filled for this account.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "lastOrderFillTimestamp",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub last_order_fill_timestamp: Option<DateTime<Utc>>,

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "NAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub nav: Option<f32>,

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginAvailable",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_available: Option<f32>,

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "positionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub position_value: Option<f32>,

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_unrealized_pl: Option<f32>,

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutNAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_nav: Option<f32>,

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_margin_used: Option<f32>,

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_percent: Option<f32>,

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPositionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_position_value: Option<f32>,

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "withdrawalLimit",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub withdrawal_limit: Option<f32>,

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCallMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_margin_used: Option<f32>,

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCallPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_percent: Option<f32>,

    /// The ID of the last Transaction created for the Account.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "lastTransactionID", skip_serializing_if = "Option::is_none")]
    pub last_transaction_id: Option<String>,

    /// The details of the Trades currently open in the Account.
    #[serde(default)]
    #[serde(rename = "trades", skip_serializing_if = "Option::is_none")]
    pub trades: Option<Vec<TradeSummary>>,

    /// The details all Account Positions.
    #[serde(default)]
    #[serde(rename = "positions", skip_serializing_if = "Option::is_none")]
    pub positions: Option<Vec<Position>>,

    /// The details of the Orders currently pending in the Account.
    #[serde(default)]
    #[serde(rename = "orders", skip_serializing_if = "Option::is_none")]
    pub orders: Option<Vec<Order>>,
}

impl Account {
    pub fn new() -> Account {
        Account {
            id: None,
            alias: None,
            currency: None,
            balance: None,
            created_by_user_id: None,
            created_time: None,
            guaranteed_stop_loss_order_mode: None,
            pl: None,
            resettable_pl: None,
            resettable_pl_time: None,
            financing: None,
            commission: None,
            guaranteed_execution_fees: None,
            margin_rate: None,
            margin_call_enter_time: None,
            margin_call_extension_count: None,
            last_margin_call_extension_time: None,
            open_trade_count: None,
            open_position_count: None,
            pending_order_count: None,
            hedging_enabled: None,
            last_order_fill_timestamp: None,
            unrealized_pl: None,
            nav: None,
            margin_used: None,
            margin_available: None,
            position_value: None,
            margin_closeout_unrealized_pl: None,
            margin_closeout_nav: None,
            margin_closeout_margin_used: None,
            margin_closeout_percent: None,
            margin_closeout_position_value: None,
            withdrawal_limit: None,
            margin_call_margin_used: None,
            margin_call_percent: None,
            last_transaction_id: None,
            trades: None,
            positions: None,
            orders: None,
        }
    }

    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return Account
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    /// - param String
    /// - return Account
    pub fn with_alias(mut self, x: String) -> Self {
        self.alias = Some(x);
        self
    }

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    /// - param String
    /// - return Account
    pub fn with_currency(mut self, x: String) -> Self {
        self.currency = Some(x);
        self
    }

    /// The current balance of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_balance(mut self, x: f32) -> Self {
        self.balance = Some(x);
        self
    }

    /// ID of the user that created the Account.
    /// - param i32
    /// - return Account
    pub fn with_created_by_user_id(mut self, x: i32) -> Self {
        self.created_by_user_id = Some(x);
        self
    }

    /// The date/time when the Account was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Account
    pub fn with_created_time(mut self, x: DateTime<Utc>) -> Self {
        self.created_time = Some(x);
        self
    }

    /// The current guaranteed Stop Loss Order mode of the Account.
    /// - param String
    /// - return Account
    pub fn with_guaranteed_stop_loss_order_mode(mut self, x: String) -> Self {
        self.guaranteed_stop_loss_order_mode = Some(x);
        self
    }

    /// The total profit/loss realized over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_pl(mut self, x: f32) -> Self {
        self.pl = Some(x);
        self
    }

    /// The total realized profit/loss for the Account since it was last reset
    /// by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_resettable_pl(mut self, x: f32) -> Self {
        self.resettable_pl = Some(x);
        self
    }

    /// The date/time that the Account's resettablePL was last reset.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Account
    pub fn with_resettable_pl_time(mut self, x: DateTime<Utc>) -> Self {
        self.resettable_pl_time = Some(x);
        self
    }

    /// The total amount of financing paid/collected over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The total amount of commission paid over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_commission(mut self, x: f32) -> Self {
        self.commission = Some(x);
        self
    }

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_guaranteed_execution_fees(mut self, x: f32) -> Self {
        self.guaranteed_execution_fees = Some(x);
        self
    }

    /// Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided if
    /// a margin rate override exists for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Account
    pub fn with_margin_rate(mut self, x: f32) -> Self {
        self.margin_rate = Some(x);
        self
    }

    /// The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Account
    pub fn with_margin_call_enter_time(mut self, x: DateTime<Utc>) -> Self {
        self.margin_call_enter_time = Some(x);
        self
    }

    /// The number of times that the Account's current margin call was
    /// extended.
    /// - param i32
    /// - return Account
    pub fn with_margin_call_extension_count(mut self, x: i32) -> Self {
        self.margin_call_extension_count = Some(x);
        self
    }

    /// The date/time of the Account's last margin call extension.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Account
    pub fn with_last_margin_call_extension_time(mut self, x: DateTime<Utc>) -> Self {
        self.last_margin_call_extension_time = Some(x);
        self
    }

    /// The number of Trades currently open in the Account.
    /// - param i32
    /// - return Account
    pub fn with_open_trade_count(mut self, x: i32) -> Self {
        self.open_trade_count = Some(x);
        self
    }

    /// The number of Positions currently open in the Account.
    /// - param i32
    /// - return Account
    pub fn with_open_position_count(mut self, x: i32) -> Self {
        self.open_position_count = Some(x);
        self
    }

    /// The number of Orders currently pending in the Account.
    /// - param i32
    /// - return Account
    pub fn with_pending_order_count(mut self, x: i32) -> Self {
        self.pending_order_count = Some(x);
        self
    }

    /// Flag indicating that the Account has hedging enabled.
    /// - param bool
    /// - return Account
    pub fn with_hedging_enabled(mut self, x: bool) -> Self {
        self.hedging_enabled = Some(x);
        self
    }

    /// The date/time of the last order that was filled for this account.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Account
    pub fn with_last_order_fill_timestamp(mut self, x: DateTime<Utc>) -> Self {
        self.last_order_fill_timestamp = Some(x);
        self
    }

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_nav(mut self, x: f32) -> Self {
        self.nav = Some(x);
        self
    }

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_available(mut self, x: f32) -> Self {
        self.margin_available = Some(x);
        self
    }

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_position_value(mut self, x: f32) -> Self {
        self.position_value = Some(x);
        self
    }

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_closeout_unrealized_pl(mut self, x: f32) -> Self {
        self.margin_closeout_unrealized_pl = Some(x);
        self
    }

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_closeout_nav(mut self, x: f32) -> Self {
        self.margin_closeout_nav = Some(x);
        self
    }

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_closeout_margin_used(mut self, x: f32) -> Self {
        self.margin_closeout_margin_used = Some(x);
        self
    }

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Account
    pub fn with_margin_closeout_percent(mut self, x: f32) -> Self {
        self.margin_closeout_percent = Some(x);
        self
    }

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Account
    pub fn with_margin_closeout_position_value(mut self, x: f32) -> Self {
        self.margin_closeout_position_value = Some(x);
        self
    }

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_withdrawal_limit(mut self, x: f32) -> Self {
        self.withdrawal_limit = Some(x);
        self
    }

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return Account
    pub fn with_margin_call_margin_used(mut self, x: f32) -> Self {
        self.margin_call_margin_used = Some(x);
        self
    }

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return Account
    pub fn with_margin_call_percent(mut self, x: f32) -> Self {
        self.margin_call_percent = Some(x);
        self
    }

    /// The ID of the last Transaction created for the Account.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return Account
    pub fn with_last_transaction_id(mut self, x: String) -> Self {
        self.last_transaction_id = Some(x);
        self
    }

    /// The details of the Trades currently open in the Account.
    /// - param Vec<TradeSummary>
    /// - return Account
    pub fn with_trades(mut self, x: Vec<TradeSummary>) -> Self {
        self.trades = Some(x);
        self
    }

    /// The details all Account Positions.
    /// - param Vec<Position>
    /// - return Account
    pub fn with_positions(mut self, x: Vec<Position>) -> Self {
        self.positions = Some(x);
        self
    }

    /// The details of the Orders currently pending in the Account.
    /// - param Vec<Order>
    /// - return Account
    pub fn with_orders(mut self, x: Vec<Order>) -> Self {
        self.orders = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountChangesState {
    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "NAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub nav: Option<f32>,

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginAvailable",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_available: Option<f32>,

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "positionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub position_value: Option<f32>,

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_unrealized_pl: Option<f32>,

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutNAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_nav: Option<f32>,

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_margin_used: Option<f32>,

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_percent: Option<f32>,

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPositionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_position_value: Option<f32>,

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "withdrawalLimit",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub withdrawal_limit: Option<f32>,

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCallMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_margin_used: Option<f32>,

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCallPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_percent: Option<f32>,

    /// The price-dependent state of each pending Order in the Account.
    #[serde(default)]
    #[serde(rename = "orders", skip_serializing_if = "Option::is_none")]
    pub orders: Option<Vec<DynamicOrderState>>,

    /// The price-dependent state for each open Trade in the Account.
    #[serde(default)]
    #[serde(rename = "trades", skip_serializing_if = "Option::is_none")]
    pub trades: Option<Vec<CalculatedTradeState>>,

    /// The price-dependent state for each open Position in the Account.
    #[serde(default)]
    #[serde(rename = "positions", skip_serializing_if = "Option::is_none")]
    pub positions: Option<Vec<CalculatedPositionState>>,
}

impl AccountChangesState {
    pub fn new() -> AccountChangesState {
        AccountChangesState {
            unrealized_pl: None,
            nav: None,
            margin_used: None,
            margin_available: None,
            position_value: None,
            margin_closeout_unrealized_pl: None,
            margin_closeout_nav: None,
            margin_closeout_margin_used: None,
            margin_closeout_percent: None,
            margin_closeout_position_value: None,
            withdrawal_limit: None,
            margin_call_margin_used: None,
            margin_call_percent: None,
            orders: None,
            trades: None,
            positions: None,
        }
    }

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_nav(mut self, x: f32) -> Self {
        self.nav = Some(x);
        self
    }

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_available(mut self, x: f32) -> Self {
        self.margin_available = Some(x);
        self
    }

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_position_value(mut self, x: f32) -> Self {
        self.position_value = Some(x);
        self
    }

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_closeout_unrealized_pl(mut self, x: f32) -> Self {
        self.margin_closeout_unrealized_pl = Some(x);
        self
    }

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_closeout_nav(mut self, x: f32) -> Self {
        self.margin_closeout_nav = Some(x);
        self
    }

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_closeout_margin_used(mut self, x: f32) -> Self {
        self.margin_closeout_margin_used = Some(x);
        self
    }

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_closeout_percent(mut self, x: f32) -> Self {
        self.margin_closeout_percent = Some(x);
        self
    }

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_closeout_position_value(mut self, x: f32) -> Self {
        self.margin_closeout_position_value = Some(x);
        self
    }

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_withdrawal_limit(mut self, x: f32) -> Self {
        self.withdrawal_limit = Some(x);
        self
    }

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_call_margin_used(mut self, x: f32) -> Self {
        self.margin_call_margin_used = Some(x);
        self
    }

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountChangesState
    pub fn with_margin_call_percent(mut self, x: f32) -> Self {
        self.margin_call_percent = Some(x);
        self
    }

    /// The price-dependent state of each pending Order in the Account.
    /// - param Vec<DynamicOrderState>
    /// - return AccountChangesState
    pub fn with_orders(mut self, x: Vec<DynamicOrderState>) -> Self {
        self.orders = Some(x);
        self
    }

    /// The price-dependent state for each open Trade in the Account.
    /// - param Vec<CalculatedTradeState>
    /// - return AccountChangesState
    pub fn with_trades(mut self, x: Vec<CalculatedTradeState>) -> Self {
        self.trades = Some(x);
        self
    }

    /// The price-dependent state for each open Position in the Account.
    /// - param Vec<CalculatedPositionState>
    /// - return AccountChangesState
    pub fn with_positions(mut self, x: Vec<CalculatedPositionState>) -> Self {
        self.positions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountProperties {
    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The Account's associated MT4 Account ID. This field will not be
    /// present if the Account is not an MT4 account.
    #[serde(default)]
    #[serde(rename = "mt4AccountID", skip_serializing_if = "Option::is_none")]
    pub mt4_account_id: Option<i32>,

    /// The Account's tags
    #[serde(default)]
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

impl AccountProperties {
    pub fn new() -> AccountProperties {
        AccountProperties {
            id: None,
            mt4_account_id: None,
            tags: None,
        }
    }

    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return AccountProperties
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The Account's associated MT4 Account ID. This field will not be
    /// present if the Account is not an MT4 account.
    /// - param i32
    /// - return AccountProperties
    pub fn with_mt4_account_id(mut self, x: i32) -> Self {
        self.mt4_account_id = Some(x);
        self
    }

    /// The Account's tags
    /// - param Vec<String>
    /// - return AccountProperties
    pub fn with_tags(mut self, x: Vec<String>) -> Self {
        self.tags = Some(x);
        self
    }
}

/// The overall behaviour of the Account regarding guaranteed Stop Loss
/// Orders.
#[derive(Debug, Serialize, Deserialize)]
pub enum GuaranteedStopLossOrderMode {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "ALLOWED")]
    Allowed,
    #[serde(rename = "REQUIRED")]
    Required,
}

impl FromStr for GuaranteedStopLossOrderMode {
    type Err = ();
    fn from_str(s: &str) -> Result<GuaranteedStopLossOrderMode, ()> {
        match s {
            "DISABLED" => Ok(GuaranteedStopLossOrderMode::Disabled),
            "ALLOWED" => Ok(GuaranteedStopLossOrderMode::Allowed),
            "REQUIRED" => Ok(GuaranteedStopLossOrderMode::Required),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for GuaranteedStopLossOrderMode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountSummary {
    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    #[serde(default)]
    #[serde(rename = "alias", skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    #[serde(default)]
    #[serde(rename = "currency", skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,

    /// The current balance of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "balance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub balance: Option<f32>,

    /// ID of the user that created the Account.
    #[serde(default)]
    #[serde(rename = "createdByUserID", skip_serializing_if = "Option::is_none")]
    pub created_by_user_id: Option<i32>,

    /// The date/time when the Account was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub created_time: Option<DateTime<Utc>>,

    /// The current guaranteed Stop Loss Order mode of the Account.
    #[serde(default)]
    #[serde(
        rename = "guaranteedStopLossOrderMode",
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_mode: Option<String>,

    /// The total profit/loss realized over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "pl",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub pl: Option<f32>,

    /// The total realized profit/loss for the Account since it was last reset
    /// by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "resettablePL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub resettable_pl: Option<f32>,

    /// The date/time that the Account's resettablePL was last reset.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "resettablePLTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub resettable_pl_time: Option<DateTime<Utc>>,

    /// The total amount of financing paid/collected over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The total amount of commission paid over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "commission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub commission: Option<f32>,

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFees",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fees: Option<f32>,

    /// Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided if
    /// a margin rate override exists for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_rate: Option<f32>,

    /// The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "marginCallEnterTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub margin_call_enter_time: Option<DateTime<Utc>>,

    /// The number of times that the Account's current margin call was
    /// extended.
    #[serde(default)]
    #[serde(
        rename = "marginCallExtensionCount",
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_extension_count: Option<i32>,

    /// The date/time of the Account's last margin call extension.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "lastMarginCallExtensionTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub last_margin_call_extension_time: Option<DateTime<Utc>>,

    /// The number of Trades currently open in the Account.
    #[serde(default)]
    #[serde(rename = "openTradeCount", skip_serializing_if = "Option::is_none")]
    pub open_trade_count: Option<i32>,

    /// The number of Positions currently open in the Account.
    #[serde(default)]
    #[serde(rename = "openPositionCount", skip_serializing_if = "Option::is_none")]
    pub open_position_count: Option<i32>,

    /// The number of Orders currently pending in the Account.
    #[serde(default)]
    #[serde(rename = "pendingOrderCount", skip_serializing_if = "Option::is_none")]
    pub pending_order_count: Option<i32>,

    /// Flag indicating that the Account has hedging enabled.
    #[serde(default)]
    #[serde(rename = "hedgingEnabled", skip_serializing_if = "Option::is_none")]
    pub hedging_enabled: Option<bool>,

    /// The date/time of the last order that was filled for this account.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "lastOrderFillTimestamp",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub last_order_fill_timestamp: Option<DateTime<Utc>>,

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "NAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub nav: Option<f32>,

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginAvailable",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_available: Option<f32>,

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "positionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub position_value: Option<f32>,

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_unrealized_pl: Option<f32>,

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutNAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_nav: Option<f32>,

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_margin_used: Option<f32>,

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_percent: Option<f32>,

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPositionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_position_value: Option<f32>,

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "withdrawalLimit",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub withdrawal_limit: Option<f32>,

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCallMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_margin_used: Option<f32>,

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCallPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_percent: Option<f32>,

    /// The ID of the last Transaction created for the Account.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "lastTransactionID", skip_serializing_if = "Option::is_none")]
    pub last_transaction_id: Option<String>,
}

impl AccountSummary {
    pub fn new() -> AccountSummary {
        AccountSummary {
            id: None,
            alias: None,
            currency: None,
            balance: None,
            created_by_user_id: None,
            created_time: None,
            guaranteed_stop_loss_order_mode: None,
            pl: None,
            resettable_pl: None,
            resettable_pl_time: None,
            financing: None,
            commission: None,
            guaranteed_execution_fees: None,
            margin_rate: None,
            margin_call_enter_time: None,
            margin_call_extension_count: None,
            last_margin_call_extension_time: None,
            open_trade_count: None,
            open_position_count: None,
            pending_order_count: None,
            hedging_enabled: None,
            last_order_fill_timestamp: None,
            unrealized_pl: None,
            nav: None,
            margin_used: None,
            margin_available: None,
            position_value: None,
            margin_closeout_unrealized_pl: None,
            margin_closeout_nav: None,
            margin_closeout_margin_used: None,
            margin_closeout_percent: None,
            margin_closeout_position_value: None,
            withdrawal_limit: None,
            margin_call_margin_used: None,
            margin_call_percent: None,
            last_transaction_id: None,
        }
    }

    /// The Account's identifier
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return AccountSummary
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    /// - param String
    /// - return AccountSummary
    pub fn with_alias(mut self, x: String) -> Self {
        self.alias = Some(x);
        self
    }

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    /// - param String
    /// - return AccountSummary
    pub fn with_currency(mut self, x: String) -> Self {
        self.currency = Some(x);
        self
    }

    /// The current balance of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_balance(mut self, x: f32) -> Self {
        self.balance = Some(x);
        self
    }

    /// ID of the user that created the Account.
    /// - param i32
    /// - return AccountSummary
    pub fn with_created_by_user_id(mut self, x: i32) -> Self {
        self.created_by_user_id = Some(x);
        self
    }

    /// The date/time when the Account was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return AccountSummary
    pub fn with_created_time(mut self, x: DateTime<Utc>) -> Self {
        self.created_time = Some(x);
        self
    }

    /// The current guaranteed Stop Loss Order mode of the Account.
    /// - param String
    /// - return AccountSummary
    pub fn with_guaranteed_stop_loss_order_mode(mut self, x: String) -> Self {
        self.guaranteed_stop_loss_order_mode = Some(x);
        self
    }

    /// The total profit/loss realized over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_pl(mut self, x: f32) -> Self {
        self.pl = Some(x);
        self
    }

    /// The total realized profit/loss for the Account since it was last reset
    /// by the client.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_resettable_pl(mut self, x: f32) -> Self {
        self.resettable_pl = Some(x);
        self
    }

    /// The date/time that the Account's resettablePL was last reset.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return AccountSummary
    pub fn with_resettable_pl_time(mut self, x: DateTime<Utc>) -> Self {
        self.resettable_pl_time = Some(x);
        self
    }

    /// The total amount of financing paid/collected over the lifetime of the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The total amount of commission paid over the lifetime of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_commission(mut self, x: f32) -> Self {
        self.commission = Some(x);
        self
    }

    /// The total amount of fees charged over the lifetime of the Account for
    /// the execution of guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_guaranteed_execution_fees(mut self, x: f32) -> Self {
        self.guaranteed_execution_fees = Some(x);
        self
    }

    /// Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided if
    /// a margin rate override exists for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_rate(mut self, x: f32) -> Self {
        self.margin_rate = Some(x);
        self
    }

    /// The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return AccountSummary
    pub fn with_margin_call_enter_time(mut self, x: DateTime<Utc>) -> Self {
        self.margin_call_enter_time = Some(x);
        self
    }

    /// The number of times that the Account's current margin call was
    /// extended.
    /// - param i32
    /// - return AccountSummary
    pub fn with_margin_call_extension_count(mut self, x: i32) -> Self {
        self.margin_call_extension_count = Some(x);
        self
    }

    /// The date/time of the Account's last margin call extension.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return AccountSummary
    pub fn with_last_margin_call_extension_time(mut self, x: DateTime<Utc>) -> Self {
        self.last_margin_call_extension_time = Some(x);
        self
    }

    /// The number of Trades currently open in the Account.
    /// - param i32
    /// - return AccountSummary
    pub fn with_open_trade_count(mut self, x: i32) -> Self {
        self.open_trade_count = Some(x);
        self
    }

    /// The number of Positions currently open in the Account.
    /// - param i32
    /// - return AccountSummary
    pub fn with_open_position_count(mut self, x: i32) -> Self {
        self.open_position_count = Some(x);
        self
    }

    /// The number of Orders currently pending in the Account.
    /// - param i32
    /// - return AccountSummary
    pub fn with_pending_order_count(mut self, x: i32) -> Self {
        self.pending_order_count = Some(x);
        self
    }

    /// Flag indicating that the Account has hedging enabled.
    /// - param bool
    /// - return AccountSummary
    pub fn with_hedging_enabled(mut self, x: bool) -> Self {
        self.hedging_enabled = Some(x);
        self
    }

    /// The date/time of the last order that was filled for this account.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return AccountSummary
    pub fn with_last_order_fill_timestamp(mut self, x: DateTime<Utc>) -> Self {
        self.last_order_fill_timestamp = Some(x);
        self
    }

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_nav(mut self, x: f32) -> Self {
        self.nav = Some(x);
        self
    }

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_available(mut self, x: f32) -> Self {
        self.margin_available = Some(x);
        self
    }

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_position_value(mut self, x: f32) -> Self {
        self.position_value = Some(x);
        self
    }

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_closeout_unrealized_pl(mut self, x: f32) -> Self {
        self.margin_closeout_unrealized_pl = Some(x);
        self
    }

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_closeout_nav(mut self, x: f32) -> Self {
        self.margin_closeout_nav = Some(x);
        self
    }

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_closeout_margin_used(mut self, x: f32) -> Self {
        self.margin_closeout_margin_used = Some(x);
        self
    }

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_closeout_percent(mut self, x: f32) -> Self {
        self.margin_closeout_percent = Some(x);
        self
    }

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_closeout_position_value(mut self, x: f32) -> Self {
        self.margin_closeout_position_value = Some(x);
        self
    }

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_withdrawal_limit(mut self, x: f32) -> Self {
        self.withdrawal_limit = Some(x);
        self
    }

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_call_margin_used(mut self, x: f32) -> Self {
        self.margin_call_margin_used = Some(x);
        self
    }

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return AccountSummary
    pub fn with_margin_call_percent(mut self, x: f32) -> Self {
        self.margin_call_percent = Some(x);
        self
    }

    /// The ID of the last Transaction created for the Account.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return AccountSummary
    pub fn with_last_transaction_id(mut self, x: String) -> Self {
        self.last_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculatedAccountState {
    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "unrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub unrealized_pl: Option<f32>,

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "NAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub nav: Option<f32>,

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_used: Option<f32>,

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginAvailable",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_available: Option<f32>,

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "positionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub position_value: Option<f32>,

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_unrealized_pl: Option<f32>,

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutNAV",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_nav: Option<f32>,

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_margin_used: Option<f32>,

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_percent: Option<f32>,

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCloseoutPositionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_closeout_position_value: Option<f32>,

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "withdrawalLimit",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub withdrawal_limit: Option<f32>,

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "marginCallMarginUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_margin_used: Option<f32>,

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginCallPercent",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_call_percent: Option<f32>,
}

impl CalculatedAccountState {
    pub fn new() -> CalculatedAccountState {
        CalculatedAccountState {
            unrealized_pl: None,
            nav: None,
            margin_used: None,
            margin_available: None,
            position_value: None,
            margin_closeout_unrealized_pl: None,
            margin_closeout_nav: None,
            margin_closeout_margin_used: None,
            margin_closeout_percent: None,
            margin_closeout_position_value: None,
            withdrawal_limit: None,
            margin_call_margin_used: None,
            margin_call_percent: None,
        }
    }

    /// The total unrealized profit/loss for all Trades currently open in the
    /// Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_unrealized_pl(mut self, x: f32) -> Self {
        self.unrealized_pl = Some(x);
        self
    }

    /// The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_nav(mut self, x: f32) -> Self {
        self.nav = Some(x);
        self
    }

    /// Margin currently used for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_used(mut self, x: f32) -> Self {
        self.margin_used = Some(x);
        self
    }

    /// Margin available for Account currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_available(mut self, x: f32) -> Self {
        self.margin_available = Some(x);
        self
    }

    /// The value of the Account's open positions represented in the Account's
    /// home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_position_value(mut self, x: f32) -> Self {
        self.position_value = Some(x);
        self
    }

    /// The Account's margin closeout unrealized PL.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_closeout_unrealized_pl(mut self, x: f32) -> Self {
        self.margin_closeout_unrealized_pl = Some(x);
        self
    }

    /// The Account's margin closeout NAV.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_closeout_nav(mut self, x: f32) -> Self {
        self.margin_closeout_nav = Some(x);
        self
    }

    /// The Account's margin closeout margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_closeout_margin_used(mut self, x: f32) -> Self {
        self.margin_closeout_margin_used = Some(x);
        self
    }

    /// The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_closeout_percent(mut self, x: f32) -> Self {
        self.margin_closeout_percent = Some(x);
        self
    }

    /// The value of the Account's open positions as used for margin closeout
    /// calculations represented in the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_closeout_position_value(mut self, x: f32) -> Self {
        self.margin_closeout_position_value = Some(x);
        self
    }

    /// The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_withdrawal_limit(mut self, x: f32) -> Self {
        self.withdrawal_limit = Some(x);
        self
    }

    /// The Account's margin call margin used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_call_margin_used(mut self, x: f32) -> Self {
        self.margin_call_margin_used = Some(x);
        self
    }

    /// The Account's margin call percentage. When this value is 1.0 or above
    /// the Account is in a margin call situation.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return CalculatedAccountState
    pub fn with_margin_call_percent(mut self, x: f32) -> Self {
        self.margin_call_percent = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountChanges {
    /// The Orders created. These Orders may have been filled, cancelled or
    /// triggered in the same period.
    #[serde(default)]
    #[serde(rename = "ordersCreated", skip_serializing_if = "Option::is_none")]
    pub orders_created: Option<Vec<Order>>,

    /// The Orders cancelled.
    #[serde(default)]
    #[serde(rename = "ordersCancelled", skip_serializing_if = "Option::is_none")]
    pub orders_cancelled: Option<Vec<Order>>,

    /// The Orders filled.
    #[serde(default)]
    #[serde(rename = "ordersFilled", skip_serializing_if = "Option::is_none")]
    pub orders_filled: Option<Vec<Order>>,

    /// The Orders triggered.
    #[serde(default)]
    #[serde(rename = "ordersTriggered", skip_serializing_if = "Option::is_none")]
    pub orders_triggered: Option<Vec<Order>>,

    /// The Trades opened.
    #[serde(default)]
    #[serde(rename = "tradesOpened", skip_serializing_if = "Option::is_none")]
    pub trades_opened: Option<Vec<TradeSummary>>,

    /// The Trades reduced.
    #[serde(default)]
    #[serde(rename = "tradesReduced", skip_serializing_if = "Option::is_none")]
    pub trades_reduced: Option<Vec<TradeSummary>>,

    /// The Trades closed.
    #[serde(default)]
    #[serde(rename = "tradesClosed", skip_serializing_if = "Option::is_none")]
    pub trades_closed: Option<Vec<TradeSummary>>,

    /// The Positions changed.
    #[serde(default)]
    #[serde(rename = "positions", skip_serializing_if = "Option::is_none")]
    pub positions: Option<Vec<Position>>,

    /// The Transactions that have been generated.
    #[serde(default)]
    #[serde(rename = "transactions", skip_serializing_if = "Option::is_none")]
    pub transactions: Option<Vec<Transaction>>,
}

impl AccountChanges {
    pub fn new() -> AccountChanges {
        AccountChanges {
            orders_created: None,
            orders_cancelled: None,
            orders_filled: None,
            orders_triggered: None,
            trades_opened: None,
            trades_reduced: None,
            trades_closed: None,
            positions: None,
            transactions: None,
        }
    }

    /// The Orders created. These Orders may have been filled, cancelled or
    /// triggered in the same period.
    /// - param Vec<Order>
    /// - return AccountChanges
    pub fn with_orders_created(mut self, x: Vec<Order>) -> Self {
        self.orders_created = Some(x);
        self
    }

    /// The Orders cancelled.
    /// - param Vec<Order>
    /// - return AccountChanges
    pub fn with_orders_cancelled(mut self, x: Vec<Order>) -> Self {
        self.orders_cancelled = Some(x);
        self
    }

    /// The Orders filled.
    /// - param Vec<Order>
    /// - return AccountChanges
    pub fn with_orders_filled(mut self, x: Vec<Order>) -> Self {
        self.orders_filled = Some(x);
        self
    }

    /// The Orders triggered.
    /// - param Vec<Order>
    /// - return AccountChanges
    pub fn with_orders_triggered(mut self, x: Vec<Order>) -> Self {
        self.orders_triggered = Some(x);
        self
    }

    /// The Trades opened.
    /// - param Vec<TradeSummary>
    /// - return AccountChanges
    pub fn with_trades_opened(mut self, x: Vec<TradeSummary>) -> Self {
        self.trades_opened = Some(x);
        self
    }

    /// The Trades reduced.
    /// - param Vec<TradeSummary>
    /// - return AccountChanges
    pub fn with_trades_reduced(mut self, x: Vec<TradeSummary>) -> Self {
        self.trades_reduced = Some(x);
        self
    }

    /// The Trades closed.
    /// - param Vec<TradeSummary>
    /// - return AccountChanges
    pub fn with_trades_closed(mut self, x: Vec<TradeSummary>) -> Self {
        self.trades_closed = Some(x);
        self
    }

    /// The Positions changed.
    /// - param Vec<Position>
    /// - return AccountChanges
    pub fn with_positions(mut self, x: Vec<Position>) -> Self {
        self.positions = Some(x);
        self
    }

    /// The Transactions that have been generated.
    /// - param Vec<Transaction>
    /// - return AccountChanges
    pub fn with_transactions(mut self, x: Vec<Transaction>) -> Self {
        self.transactions = Some(x);
        self
    }
}

/// The financing mode of an Account
#[derive(Debug, Serialize, Deserialize)]
pub enum AccountFinancingMode {
    #[serde(rename = "NO_FINANCING")]
    NoFinancing,
    #[serde(rename = "SECOND_BY_SECOND")]
    SecondBySecond,
    #[serde(rename = "DAILY")]
    Daily,
}

impl FromStr for AccountFinancingMode {
    type Err = ();
    fn from_str(s: &str) -> Result<AccountFinancingMode, ()> {
        match s {
            "NO_FINANCING" => Ok(AccountFinancingMode::NoFinancing),
            "SECOND_BY_SECOND" => Ok(AccountFinancingMode::SecondBySecond),
            "DAILY" => Ok(AccountFinancingMode::Daily),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for AccountFinancingMode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The way that position values for an Account are calculated and
/// aggregated.
#[derive(Debug, Serialize, Deserialize)]
pub enum PositionAggregationMode {
    #[serde(rename = "ABSOLUTE_SUM")]
    AbsoluteSum,
    #[serde(rename = "MAXIMAL_SIDE")]
    MaximalSide,
    #[serde(rename = "NET_SUM")]
    NetSum,
}

impl FromStr for PositionAggregationMode {
    type Err = ();
    fn from_str(s: &str) -> Result<PositionAggregationMode, ()> {
        match s {
            "ABSOLUTE_SUM" => Ok(PositionAggregationMode::AbsoluteSum),
            "MAXIMAL_SIDE" => Ok(PositionAggregationMode::MaximalSide),
            "NET_SUM" => Ok(PositionAggregationMode::NetSum),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for PositionAggregationMode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The possible types of a Transaction
#[derive(Debug, Serialize, Deserialize)]
pub enum TransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl FromStr for TransactionType {
    type Err = ();
    fn from_str(s: &str) -> Result<TransactionType, ()> {
        match s {
            "CREATE" => Ok(TransactionType::Create),
            "CLOSE" => Ok(TransactionType::Close),
            "REOPEN" => Ok(TransactionType::Reopen),
            "CLIENT_CONFIGURE" => Ok(TransactionType::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(TransactionType::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(TransactionType::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(TransactionType::TransferFundsReject),
            "MARKET_ORDER" => Ok(TransactionType::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(TransactionType::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(TransactionType::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(TransactionType::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(TransactionType::LimitOrderReject),
            "STOP_ORDER" => Ok(TransactionType::StopOrder),
            "STOP_ORDER_REJECT" => Ok(TransactionType::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(TransactionType::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(TransactionType::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(TransactionType::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(TransactionType::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(TransactionType::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(TransactionType::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(TransactionType::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(TransactionType::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(TransactionType::OrderFill),
            "ORDER_CANCEL" => Ok(TransactionType::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(TransactionType::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(TransactionType::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => {
                Ok(TransactionType::OrderClientExtensionsModifyReject)
            }
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(TransactionType::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => {
                Ok(TransactionType::TradeClientExtensionsModifyReject)
            }
            "MARGIN_CALL_ENTER" => Ok(TransactionType::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(TransactionType::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(TransactionType::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(TransactionType::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(TransactionType::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(TransactionType::ResetResettablePl),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TransactionType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Transaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
}

impl Transaction {
    pub fn new() -> Transaction {
        Transaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return Transaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Transaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return Transaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return Transaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return Transaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return Transaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "CREATE" in a
    /// CreateTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Division that the Account is in
    #[serde(default)]
    #[serde(rename = "divisionID", skip_serializing_if = "Option::is_none")]
    pub division_id: Option<i32>,

    /// The ID of the Site that the Account was created at
    #[serde(default)]
    #[serde(rename = "siteID", skip_serializing_if = "Option::is_none")]
    pub site_id: Option<i32>,

    /// The ID of the user that the Account was created for
    #[serde(default)]
    #[serde(rename = "accountUserID", skip_serializing_if = "Option::is_none")]
    pub account_user_id: Option<i32>,

    /// The number of the Account within the site/division/user
    #[serde(default)]
    #[serde(rename = "accountNumber", skip_serializing_if = "Option::is_none")]
    pub account_number: Option<i32>,

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    #[serde(default)]
    #[serde(rename = "homeCurrency", skip_serializing_if = "Option::is_none")]
    pub home_currency: Option<String>,
}

impl CreateTransaction {
    pub fn new() -> CreateTransaction {
        CreateTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            division_id: None,
            site_id: None,
            account_user_id: None,
            account_number: None,
            home_currency: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return CreateTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return CreateTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return CreateTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return CreateTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return CreateTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return CreateTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "CREATE" in a
    /// CreateTransaction.
    /// - param String
    /// - return CreateTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Division that the Account is in
    /// - param i32
    /// - return CreateTransaction
    pub fn with_division_id(mut self, x: i32) -> Self {
        self.division_id = Some(x);
        self
    }

    /// The ID of the Site that the Account was created at
    /// - param i32
    /// - return CreateTransaction
    pub fn with_site_id(mut self, x: i32) -> Self {
        self.site_id = Some(x);
        self
    }

    /// The ID of the user that the Account was created for
    /// - param i32
    /// - return CreateTransaction
    pub fn with_account_user_id(mut self, x: i32) -> Self {
        self.account_user_id = Some(x);
        self
    }

    /// The number of the Account within the site/division/user
    /// - param i32
    /// - return CreateTransaction
    pub fn with_account_number(mut self, x: i32) -> Self {
        self.account_number = Some(x);
        self
    }

    /// The home currency of the Account
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    /// - param String
    /// - return CreateTransaction
    pub fn with_home_currency(mut self, x: String) -> Self {
        self.home_currency = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CloseTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "CLOSE" in a
    /// CloseTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,
}

impl CloseTransaction {
    pub fn new() -> CloseTransaction {
        CloseTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return CloseTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return CloseTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return CloseTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return CloseTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return CloseTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return CloseTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "CLOSE" in a
    /// CloseTransaction.
    /// - param String
    /// - return CloseTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReopenTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "REOPEN" in a
    /// ReopenTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,
}

impl ReopenTransaction {
    pub fn new() -> ReopenTransaction {
        ReopenTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ReopenTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return ReopenTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return ReopenTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return ReopenTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ReopenTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return ReopenTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "REOPEN" in a
    /// ReopenTransaction.
    /// - param String
    /// - return ReopenTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ClientConfigureTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "CLIENT_CONFIGURE" in a
    /// ClientConfigureTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The client-provided alias for the Account.
    #[serde(default)]
    #[serde(rename = "alias", skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,

    /// The margin rate override for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_rate: Option<f32>,
}

impl ClientConfigureTransaction {
    pub fn new() -> ClientConfigureTransaction {
        ClientConfigureTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            alias: None,
            margin_rate: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return ClientConfigureTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return ClientConfigureTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "CLIENT_CONFIGURE" in a
    /// ClientConfigureTransaction.
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The client-provided alias for the Account.
    /// - param String
    /// - return ClientConfigureTransaction
    pub fn with_alias(mut self, x: String) -> Self {
        self.alias = Some(x);
        self
    }

    /// The margin rate override for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return ClientConfigureTransaction
    pub fn with_margin_rate(mut self, x: f32) -> Self {
        self.margin_rate = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ClientConfigureRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "CLIENT_CONFIGURE_REJECT"
    /// in a ClientConfigureRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The client-provided alias for the Account.
    #[serde(default)]
    #[serde(rename = "alias", skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,

    /// The margin rate override for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "marginRate",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub margin_rate: Option<f32>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl ClientConfigureRejectTransaction {
    pub fn new() -> ClientConfigureRejectTransaction {
        ClientConfigureRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            alias: None,
            margin_rate: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return ClientConfigureRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return ClientConfigureRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "CLIENT_CONFIGURE_REJECT"
    /// in a ClientConfigureRejectTransaction.
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The client-provided alias for the Account.
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_alias(mut self, x: String) -> Self {
        self.alias = Some(x);
        self
    }

    /// The margin rate override for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return ClientConfigureRejectTransaction
    pub fn with_margin_rate(mut self, x: f32) -> Self {
        self.margin_rate = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return ClientConfigureRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that an Account is being funded.
#[derive(Debug, Serialize, Deserialize)]
pub enum FundingReason {
    #[serde(rename = "CLIENT_FUNDING")]
    ClientFunding,
    #[serde(rename = "ACCOUNT_TRANSFER")]
    AccountTransfer,
    #[serde(rename = "DIVISION_MIGRATION")]
    DivisionMigration,
    #[serde(rename = "SITE_MIGRATION")]
    SiteMigration,
    #[serde(rename = "ADJUSTMENT")]
    Adjustment,
}

impl FromStr for FundingReason {
    type Err = ();
    fn from_str(s: &str) -> Result<FundingReason, ()> {
        match s {
            "CLIENT_FUNDING" => Ok(FundingReason::ClientFunding),
            "ACCOUNT_TRANSFER" => Ok(FundingReason::AccountTransfer),
            "DIVISION_MIGRATION" => Ok(FundingReason::DivisionMigration),
            "SITE_MIGRATION" => Ok(FundingReason::SiteMigration),
            "ADJUSTMENT" => Ok(FundingReason::Adjustment),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for FundingReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TransferFundsTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "TRANSFER_FUNDS" in a
    /// TransferFundsTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The amount to deposit/withdraw from the Account in the Account's home
    /// currency. A positive value indicates a deposit, a negative value
    /// indicates a withdrawal.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "amount",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub amount: Option<f32>,

    /// The reason that an Account is being funded.
    #[serde(default)]
    #[serde(rename = "fundingReason", skip_serializing_if = "Option::is_none")]
    pub funding_reason: Option<String>,

    /// An optional comment that may be attached to a fund transfer for audit
    /// purposes
    #[serde(default)]
    #[serde(rename = "comment", skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The Account's balance after funds are transferred.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "accountBalance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub account_balance: Option<f32>,
}

impl TransferFundsTransaction {
    pub fn new() -> TransferFundsTransaction {
        TransferFundsTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            amount: None,
            funding_reason: None,
            comment: None,
            account_balance: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TransferFundsTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TransferFundsTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "TRANSFER_FUNDS" in a
    /// TransferFundsTransaction.
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The amount to deposit/withdraw from the Account in the Account's home
    /// currency. A positive value indicates a deposit, a negative value
    /// indicates a withdrawal.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TransferFundsTransaction
    pub fn with_amount(mut self, x: f32) -> Self {
        self.amount = Some(x);
        self
    }

    /// The reason that an Account is being funded.
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_funding_reason(mut self, x: String) -> Self {
        self.funding_reason = Some(x);
        self
    }

    /// An optional comment that may be attached to a fund transfer for audit
    /// purposes
    /// - param String
    /// - return TransferFundsTransaction
    pub fn with_comment(mut self, x: String) -> Self {
        self.comment = Some(x);
        self
    }

    /// The Account's balance after funds are transferred.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TransferFundsTransaction
    pub fn with_account_balance(mut self, x: f32) -> Self {
        self.account_balance = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TransferFundsRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "TRANSFER_FUNDS_REJECT" in
    /// a TransferFundsRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The amount to deposit/withdraw from the Account in the Account's home
    /// currency. A positive value indicates a deposit, a negative value
    /// indicates a withdrawal.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "amount",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub amount: Option<f32>,

    /// The reason that an Account is being funded.
    #[serde(default)]
    #[serde(rename = "fundingReason", skip_serializing_if = "Option::is_none")]
    pub funding_reason: Option<String>,

    /// An optional comment that may be attached to a fund transfer for audit
    /// purposes
    #[serde(default)]
    #[serde(rename = "comment", skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl TransferFundsRejectTransaction {
    pub fn new() -> TransferFundsRejectTransaction {
        TransferFundsRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            amount: None,
            funding_reason: None,
            comment: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TransferFundsRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TransferFundsRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "TRANSFER_FUNDS_REJECT" in
    /// a TransferFundsRejectTransaction.
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The amount to deposit/withdraw from the Account in the Account's home
    /// currency. A positive value indicates a deposit, a negative value
    /// indicates a withdrawal.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TransferFundsRejectTransaction
    pub fn with_amount(mut self, x: f32) -> Self {
        self.amount = Some(x);
        self
    }

    /// The reason that an Account is being funded.
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_funding_reason(mut self, x: String) -> Self {
        self.funding_reason = Some(x);
        self
    }

    /// An optional comment that may be attached to a fund transfer for audit
    /// purposes
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_comment(mut self, x: String) -> Self {
        self.comment = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return TransferFundsRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Market Order was created
#[derive(Debug, Serialize, Deserialize)]
pub enum MarketOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "TRADE_CLOSE")]
    TradeClose,
    #[serde(rename = "POSITION_CLOSEOUT")]
    PositionCloseout,
    #[serde(rename = "MARGIN_CLOSEOUT")]
    MarginCloseout,
    #[serde(rename = "DELAYED_TRADE_CLOSE")]
    DelayedTradeClose,
}

impl FromStr for MarketOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<MarketOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(MarketOrderReason::ClientOrder),
            "TRADE_CLOSE" => Ok(MarketOrderReason::TradeClose),
            "POSITION_CLOSEOUT" => Ok(MarketOrderReason::PositionCloseout),
            "MARGIN_CLOSEOUT" => Ok(MarketOrderReason::MarginCloseout),
            "DELAYED_TRADE_CLOSE" => Ok(MarketOrderReason::DelayedTradeClose),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for MarketOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The reason that the Fixed Price Order was created
#[derive(Debug, Serialize, Deserialize)]
pub enum FixedPriceOrderReason {
    #[serde(rename = "PLATFORM_ACCOUNT_MIGRATION")]
    PlatformAccountMigration,
}

impl FromStr for FixedPriceOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<FixedPriceOrderReason, ()> {
        match s {
            "PLATFORM_ACCOUNT_MIGRATION" => Ok(FixedPriceOrderReason::PlatformAccountMigration),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for FixedPriceOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARKET_ORDER" in a
    /// MarketOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    #[serde(default)]
    #[serde(rename = "tradeClose", skip_serializing_if = "Option::is_none")]
    pub trade_close: Option<MarketOrderTradeClose>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "longPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "shortPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    #[serde(default)]
    #[serde(rename = "marginCloseout", skip_serializing_if = "Option::is_none")]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    #[serde(default)]
    #[serde(rename = "delayedTradeClose", skip_serializing_if = "Option::is_none")]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,

    /// The reason that the Market Order was created
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl MarketOrderTransaction {
    pub fn new() -> MarketOrderTransaction {
        MarketOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            time_in_force: None,
            price_bound: None,
            position_fill: None,
            trade_close: None,
            long_position_closeout: None,
            short_position_closeout: None,
            margin_closeout: None,
            delayed_trade_close: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarketOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARKET_ORDER" in a
    /// MarketOrderTransaction.
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketOrderTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketOrderTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    /// - param MarketOrderTradeClose
    /// - return MarketOrderTransaction
    pub fn with_trade_close(mut self, x: MarketOrderTradeClose) -> Self {
        self.trade_close = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrderTransaction
    pub fn with_long_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.long_position_closeout = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrderTransaction
    pub fn with_short_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.short_position_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    /// - param MarketOrderMarginCloseout
    /// - return MarketOrderTransaction
    pub fn with_margin_closeout(mut self, x: MarketOrderMarginCloseout) -> Self {
        self.margin_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    /// - param MarketOrderDelayedTradeClose
    /// - return MarketOrderTransaction
    pub fn with_delayed_trade_close(mut self, x: MarketOrderDelayedTradeClose) -> Self {
        self.delayed_trade_close = Some(x);
        self
    }

    /// The reason that the Market Order was created
    /// - param String
    /// - return MarketOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketOrderTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketOrderTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketOrderTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARKET_ORDER_REJECT" in a
    /// MarketOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    #[serde(default)]
    #[serde(rename = "tradeClose", skip_serializing_if = "Option::is_none")]
    pub trade_close: Option<MarketOrderTradeClose>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "longPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "shortPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    #[serde(default)]
    #[serde(rename = "marginCloseout", skip_serializing_if = "Option::is_none")]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    #[serde(default)]
    #[serde(rename = "delayedTradeClose", skip_serializing_if = "Option::is_none")]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,

    /// The reason that the Market Order was created
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl MarketOrderRejectTransaction {
    pub fn new() -> MarketOrderRejectTransaction {
        MarketOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            time_in_force: None,
            price_bound: None,
            position_fill: None,
            trade_close: None,
            long_position_closeout: None,
            short_position_closeout: None,
            margin_closeout: None,
            delayed_trade_close: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarketOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARKET_ORDER_REJECT" in a
    /// MarketOrderRejectTransaction.
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketOrderRejectTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketOrderRejectTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    /// - param MarketOrderTradeClose
    /// - return MarketOrderRejectTransaction
    pub fn with_trade_close(mut self, x: MarketOrderTradeClose) -> Self {
        self.trade_close = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrderRejectTransaction
    pub fn with_long_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.long_position_closeout = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrderRejectTransaction
    pub fn with_short_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.short_position_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    /// - param MarketOrderMarginCloseout
    /// - return MarketOrderRejectTransaction
    pub fn with_margin_closeout(mut self, x: MarketOrderMarginCloseout) -> Self {
        self.margin_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    /// - param MarketOrderDelayedTradeClose
    /// - return MarketOrderRejectTransaction
    pub fn with_delayed_trade_close(mut self, x: MarketOrderDelayedTradeClose) -> Self {
        self.delayed_trade_close = Some(x);
        self
    }

    /// The reason that the Market Order was created
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketOrderRejectTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketOrderRejectTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketOrderRejectTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderRejectTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return MarketOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FixedPriceOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "FIXED_PRICE_ORDER" in a
    /// FixedPriceOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Fixed Price Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Fixed Price Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price specified for the Fixed Price Order. This price is the exact
    /// price that the Fixed Price Order will be filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    #[serde(default)]
    #[serde(rename = "tradeState", skip_serializing_if = "Option::is_none")]
    pub trade_state: Option<String>,

    /// The reason that the Fixed Price Order was created
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl FixedPriceOrderTransaction {
    pub fn new() -> FixedPriceOrderTransaction {
        FixedPriceOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            position_fill: None,
            trade_state: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return FixedPriceOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return FixedPriceOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "FIXED_PRICE_ORDER" in a
    /// FixedPriceOrderTransaction.
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Fixed Price Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Fixed Price Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return FixedPriceOrderTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price specified for the Fixed Price Order. This price is the exact
    /// price that the Fixed Price Order will be filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return FixedPriceOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_trade_state(mut self, x: String) -> Self {
        self.trade_state = Some(x);
        self
    }

    /// The reason that the Fixed Price Order was created
    /// - param String
    /// - return FixedPriceOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return FixedPriceOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return FixedPriceOrderTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return FixedPriceOrderTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return FixedPriceOrderTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return FixedPriceOrderTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

/// The reason that the Limit Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum LimitOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl FromStr for LimitOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<LimitOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(LimitOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(LimitOrderReason::Replacement),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for LimitOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LimitOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "LIMIT_ORDER" in a
    /// LimitOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the Limit Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Limit Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl LimitOrderTransaction {
    pub fn new() -> LimitOrderTransaction {
        LimitOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return LimitOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "LIMIT_ORDER" in a
    /// LimitOrderTransaction.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LimitOrderTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return LimitOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the Limit Order.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Limit Order was initiated
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return LimitOrderTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return LimitOrderTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return LimitOrderTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LimitOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "LIMIT_ORDER_REJECT" in a
    /// LimitOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the Limit Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Limit Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl LimitOrderRejectTransaction {
    pub fn new() -> LimitOrderRejectTransaction {
        LimitOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return LimitOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "LIMIT_ORDER_REJECT" in a
    /// LimitOrderRejectTransaction.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LimitOrderRejectTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return LimitOrderRejectTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the Limit Order.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Limit Order was initiated
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return LimitOrderRejectTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return LimitOrderRejectTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return LimitOrderRejectTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderRejectTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return LimitOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Stop Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum StopOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl FromStr for StopOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<StopOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(StopOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(StopOrderReason::Replacement),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for StopOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "STOP_ORDER" in a
    /// StopOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the Stop Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Stop Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl StopOrderTransaction {
    pub fn new() -> StopOrderTransaction {
        StopOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return StopOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "STOP_ORDER" in a
    /// StopOrderTransaction.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopOrderTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the Stop Order.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Stop Order was initiated
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return StopOrderTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return StopOrderTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return StopOrderTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "STOP_ORDER_REJECT" in a
    /// StopOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the Stop Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Stop Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl StopOrderRejectTransaction {
    pub fn new() -> StopOrderRejectTransaction {
        StopOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return StopOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "STOP_ORDER_REJECT" in a
    /// StopOrderRejectTransaction.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopOrderRejectTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderRejectTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderRejectTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the Stop Order.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Stop Order was initiated
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return StopOrderRejectTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return StopOrderRejectTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return StopOrderRejectTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderRejectTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return StopOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Market-if-touched Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum MarketIfTouchedOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl FromStr for MarketIfTouchedOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<MarketIfTouchedOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(MarketIfTouchedOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(MarketIfTouchedOrderReason::Replacement),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for MarketIfTouchedOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketIfTouchedOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARKET_IF_TOUCHED_ORDER"
    /// in a MarketIfTouchedOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Market-if-touched Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl MarketIfTouchedOrderTransaction {
    pub fn new() -> MarketIfTouchedOrderTransaction {
        MarketIfTouchedOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARKET_IF_TOUCHED_ORDER"
    /// in a MarketIfTouchedOrderTransaction.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Market-if-touched Order was initiated
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketIfTouchedOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "MARKET_IF_TOUCHED_ORDER_REJECT" in a
    /// MarketIfTouchedOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Market-if-touched Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl MarketIfTouchedOrderRejectTransaction {
    pub fn new() -> MarketIfTouchedOrderRejectTransaction {
        MarketIfTouchedOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "MARKET_IF_TOUCHED_ORDER_REJECT" in a
    /// MarketIfTouchedOrderRejectTransaction.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Market-if-touched Order was initiated
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return MarketIfTouchedOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Take Profit Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum TakeProfitOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl FromStr for TakeProfitOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<TakeProfitOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(TakeProfitOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(TakeProfitOrderReason::Replacement),
            "ON_FILL" => Ok(TakeProfitOrderReason::OnFill),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TakeProfitOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TakeProfitOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER" in a
    /// TakeProfitOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Take Profit Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl TakeProfitOrderTransaction {
    pub fn new() -> TakeProfitOrderTransaction {
        TakeProfitOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TakeProfitOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER" in a
    /// TakeProfitOrderTransaction.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TakeProfitOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Take Profit Order was initiated
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TakeProfitOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TakeProfitOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER_REJECT"
    /// in a TakeProfitOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Take Profit Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl TakeProfitOrderRejectTransaction {
    pub fn new() -> TakeProfitOrderRejectTransaction {
        TakeProfitOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER_REJECT"
    /// in a TakeProfitOrderRejectTransaction.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Take Profit Order was initiated
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return TakeProfitOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Stop Loss Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum StopLossOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl FromStr for StopLossOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<StopLossOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(StopLossOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(StopLossOrderReason::Replacement),
            "ON_FILL" => Ok(StopLossOrderReason::OnFill),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for StopLossOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopLossOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "STOP_LOSS_ORDER" in a
    /// StopLossOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    #[serde(default)]
    #[serde(rename = "guaranteed", skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,

    /// The fee that will be charged if the Stop Loss Order is guaranteed and
    /// the Order is filled at the guaranteed price. The value is determined
    /// at Order creation time. It is in price units and is charged for each
    /// unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionPremium",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_premium: Option<f32>,

    /// The reason that the Stop Loss Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl StopLossOrderTransaction {
    pub fn new() -> StopLossOrderTransaction {
        StopLossOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            guaranteed: None,
            guaranteed_execution_premium: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return StopLossOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "STOP_LOSS_ORDER" in a
    /// StopLossOrderTransaction.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopLossOrderTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrderTransaction
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    /// - param bool
    /// - return StopLossOrderTransaction
    pub fn with_guaranteed(mut self, x: bool) -> Self {
        self.guaranteed = Some(x);
        self
    }

    /// The fee that will be charged if the Stop Loss Order is guaranteed and
    /// the Order is filled at the guaranteed price. The value is determined
    /// at Order creation time. It is in price units and is charged for each
    /// unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrderTransaction
    pub fn with_guaranteed_execution_premium(mut self, x: f32) -> Self {
        self.guaranteed_execution_premium = Some(x);
        self
    }

    /// The reason that the Stop Loss Order was initiated
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopLossOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopLossOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "STOP_LOSS_ORDER_REJECT" in
    /// a StopLossOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    #[serde(default)]
    #[serde(rename = "guaranteed", skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,

    /// The reason that the Stop Loss Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl StopLossOrderRejectTransaction {
    pub fn new() -> StopLossOrderRejectTransaction {
        StopLossOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            guaranteed: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return StopLossOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "STOP_LOSS_ORDER_REJECT" in
    /// a StopLossOrderRejectTransaction.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopLossOrderRejectTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrderRejectTransaction
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    /// - param bool
    /// - return StopLossOrderRejectTransaction
    pub fn with_guaranteed(mut self, x: bool) -> Self {
        self.guaranteed = Some(x);
        self
    }

    /// The reason that the Stop Loss Order was initiated
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopLossOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return StopLossOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that the Trailing Stop Loss Order was initiated
#[derive(Debug, Serialize, Deserialize)]
pub enum TrailingStopLossOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl FromStr for TrailingStopLossOrderReason {
    type Err = ();
    fn from_str(s: &str) -> Result<TrailingStopLossOrderReason, ()> {
        match s {
            "CLIENT_ORDER" => Ok(TrailingStopLossOrderReason::ClientOrder),
            "REPLACEMENT" => Ok(TrailingStopLossOrderReason::Replacement),
            "ON_FILL" => Ok(TrailingStopLossOrderReason::OnFill),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TrailingStopLossOrderReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrailingStopLossOrderTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "TRAILING_STOP_LOSS_ORDER"
    /// in a TrailingStopLossOrderTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Trailing Stop Loss Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
}

impl TrailingStopLossOrderTransaction {
    pub fn new() -> TrailingStopLossOrderTransaction {
        TrailingStopLossOrderTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            replaces_order_id: None,
            cancelling_transaction_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrderTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TrailingStopLossOrderTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "TRAILING_STOP_LOSS_ORDER"
    /// in a TrailingStopLossOrderTransaction.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TrailingStopLossOrderTransaction
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrderTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Trailing Stop Loss Order was initiated
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TrailingStopLossOrderTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderTransaction
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrailingStopLossOrderRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "TRAILING_STOP_LOSS_ORDER_REJECT" in a
    /// TrailingStopLossOrderRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The reason that the Trailing Stop Loss Order was initiated
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "orderFillTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(
        rename = "intendedReplacesOrderID",
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl TrailingStopLossOrderRejectTransaction {
    pub fn new() -> TrailingStopLossOrderRejectTransaction {
        TrailingStopLossOrderRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            reason: None,
            client_extensions: None,
            order_fill_transaction_id: None,
            intended_replaces_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "TRAILING_STOP_LOSS_ORDER_REJECT" in a
    /// TrailingStopLossOrderRejectTransaction.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The reason that the Trailing Stop Loss Order was initiated
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_order_fill_transaction_id(mut self, x: String) -> Self {
        self.order_fill_transaction_id = Some(x);
        self
    }

    /// The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_intended_replaces_order_id(mut self, x: String) -> Self {
        self.intended_replaces_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return TrailingStopLossOrderRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

/// The reason that an Order was filled
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderFillReason {
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_TRADE_CLOSE")]
    MarketOrderTradeClose,
    #[serde(rename = "MARKET_ORDER_POSITION_CLOSEOUT")]
    MarketOrderPositionCloseout,
    #[serde(rename = "MARKET_ORDER_MARGIN_CLOSEOUT")]
    MarketOrderMarginCloseout,
    #[serde(rename = "MARKET_ORDER_DELAYED_TRADE_CLOSE")]
    MarketOrderDelayedTradeClose,
}

impl FromStr for OrderFillReason {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderFillReason, ()> {
        match s {
            "LIMIT_ORDER" => Ok(OrderFillReason::LimitOrder),
            "STOP_ORDER" => Ok(OrderFillReason::StopOrder),
            "MARKET_IF_TOUCHED_ORDER" => Ok(OrderFillReason::MarketIfTouchedOrder),
            "TAKE_PROFIT_ORDER" => Ok(OrderFillReason::TakeProfitOrder),
            "STOP_LOSS_ORDER" => Ok(OrderFillReason::StopLossOrder),
            "TRAILING_STOP_LOSS_ORDER" => Ok(OrderFillReason::TrailingStopLossOrder),
            "MARKET_ORDER" => Ok(OrderFillReason::MarketOrder),
            "MARKET_ORDER_TRADE_CLOSE" => Ok(OrderFillReason::MarketOrderTradeClose),
            "MARKET_ORDER_POSITION_CLOSEOUT" => Ok(OrderFillReason::MarketOrderPositionCloseout),
            "MARKET_ORDER_MARGIN_CLOSEOUT" => Ok(OrderFillReason::MarketOrderMarginCloseout),
            "MARKET_ORDER_DELAYED_TRADE_CLOSE" => Ok(OrderFillReason::MarketOrderDelayedTradeClose),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderFillReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderFillTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "ORDER_FILL" for an
    /// OrderFillTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Order filled.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The client Order ID of the Order filled (only provided if the client
    /// has assigned one).
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,

    /// The name of the filled Order's instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The number of units filled by the OrderFill.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// This is the conversion factor in effect for the Account at the time of
    /// the OrderFill for converting any gains realized in Instrument quote
    /// units into units of the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "gainQuoteHomeConversionFactor",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub gain_quote_home_conversion_factor: Option<f32>,

    /// This is the conversion factor in effect for the Account at the time of
    /// the OrderFill for converting any losses realized in Instrument quote
    /// units into units of the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "lossQuoteHomeConversionFactor",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub loss_quote_home_conversion_factor: Option<f32>,

    /// This field is now deprecated and should no longer be used. The
    /// individual tradesClosed, tradeReduced and tradeOpened fields contain
    /// the exact/official price each unit was filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The price that all of the units of the OrderFill should have been
    /// filled at, in the absence of guaranteed price execution. This factors
    /// in the Account's current ClientPrice, used liquidity and the units of
    /// the OrderFill only. If no Trades were closed with their price clamped
    /// for guaranteed stop loss enforcement, then this value will match the
    /// price fields of each Trade opened, closed, and reduced, and they will
    /// all be the exact same.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "fullVWAP",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub full_vwap: Option<f32>,

    /// The specification of an Account-specific Price.
    #[serde(default)]
    #[serde(rename = "fullPrice", skip_serializing_if = "Option::is_none")]
    pub full_price: Option<ClientPrice>,

    /// The reason that an Order was filled
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// The profit or loss incurred when the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "pl",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub pl: Option<f32>,

    /// The financing paid or collected when the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The commission charged in the Account's home currency as a result of
    /// filling the Order. The commission is always represented as a positive
    /// quantity of the Account's home currency, however it reduces the
    /// balance in the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "commission",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub commission: Option<f32>,

    /// The total guaranteed execution fees charged for all Trades opened,
    /// closed or reduced with guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFee",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fee: Option<f32>,

    /// The Account's balance after the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "accountBalance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub account_balance: Option<f32>,

    /// A TradeOpen object represents a Trade for an instrument that was
    /// opened in an Account. It is found embedded in Transactions that affect
    /// the position of an instrument in the Account, specifically the
    /// OrderFill Transaction.
    #[serde(default)]
    #[serde(rename = "tradeOpened", skip_serializing_if = "Option::is_none")]
    pub trade_opened: Option<TradeOpen>,

    /// The Trades that were closed when the Order was filled (only provided
    /// if filling the Order resulted in a closing open Trades).
    #[serde(default)]
    #[serde(rename = "tradesClosed", skip_serializing_if = "Option::is_none")]
    pub trades_closed: Option<Vec<TradeReduce>>,

    /// A TradeReduce object represents a Trade for an instrument that was
    /// reduced (either partially or fully) in an Account. It is found
    /// embedded in Transactions that affect the position of an instrument in
    /// the account, specifically the OrderFill Transaction.
    #[serde(default)]
    #[serde(rename = "tradeReduced", skip_serializing_if = "Option::is_none")]
    pub trade_reduced: Option<TradeReduce>,

    /// The half spread cost for the OrderFill, which is the sum of the
    /// halfSpreadCost values in the tradeOpened, tradesClosed and
    /// tradeReduced fields. This can be a positive or negative value and is
    /// represented in the home currency of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "halfSpreadCost",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub half_spread_cost: Option<f32>,
}

impl OrderFillTransaction {
    pub fn new() -> OrderFillTransaction {
        OrderFillTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            order_id: None,
            client_order_id: None,
            instrument: None,
            units: None,
            gain_quote_home_conversion_factor: None,
            loss_quote_home_conversion_factor: None,
            price: None,
            full_vwap: None,
            full_price: None,
            reason: None,
            pl: None,
            financing: None,
            commission: None,
            guaranteed_execution_fee: None,
            account_balance: None,
            trade_opened: None,
            trades_closed: None,
            trade_reduced: None,
            half_spread_cost: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderFillTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return OrderFillTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "ORDER_FILL" for an
    /// OrderFillTransaction.
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Order filled.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The client Order ID of the Order filled (only provided if the client
    /// has assigned one).
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }

    /// The name of the filled Order's instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The number of units filled by the OrderFill.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// This is the conversion factor in effect for the Account at the time of
    /// the OrderFill for converting any gains realized in Instrument quote
    /// units into units of the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_gain_quote_home_conversion_factor(mut self, x: f32) -> Self {
        self.gain_quote_home_conversion_factor = Some(x);
        self
    }

    /// This is the conversion factor in effect for the Account at the time of
    /// the OrderFill for converting any losses realized in Instrument quote
    /// units into units of the Account's home currency.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_loss_quote_home_conversion_factor(mut self, x: f32) -> Self {
        self.loss_quote_home_conversion_factor = Some(x);
        self
    }

    /// This field is now deprecated and should no longer be used. The
    /// individual tradesClosed, tradeReduced and tradeOpened fields contain
    /// the exact/official price each unit was filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The price that all of the units of the OrderFill should have been
    /// filled at, in the absence of guaranteed price execution. This factors
    /// in the Account's current ClientPrice, used liquidity and the units of
    /// the OrderFill only. If no Trades were closed with their price clamped
    /// for guaranteed stop loss enforcement, then this value will match the
    /// price fields of each Trade opened, closed, and reduced, and they will
    /// all be the exact same.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_full_vwap(mut self, x: f32) -> Self {
        self.full_vwap = Some(x);
        self
    }

    /// The specification of an Account-specific Price.
    /// - param ClientPrice
    /// - return OrderFillTransaction
    pub fn with_full_price(mut self, x: ClientPrice) -> Self {
        self.full_price = Some(x);
        self
    }

    /// The reason that an Order was filled
    /// - param String
    /// - return OrderFillTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// The profit or loss incurred when the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_pl(mut self, x: f32) -> Self {
        self.pl = Some(x);
        self
    }

    /// The financing paid or collected when the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The commission charged in the Account's home currency as a result of
    /// filling the Order. The commission is always represented as a positive
    /// quantity of the Account's home currency, however it reduces the
    /// balance in the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_commission(mut self, x: f32) -> Self {
        self.commission = Some(x);
        self
    }

    /// The total guaranteed execution fees charged for all Trades opened,
    /// closed or reduced with guaranteed Stop Loss Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_guaranteed_execution_fee(mut self, x: f32) -> Self {
        self.guaranteed_execution_fee = Some(x);
        self
    }

    /// The Account's balance after the Order was filled.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_account_balance(mut self, x: f32) -> Self {
        self.account_balance = Some(x);
        self
    }

    /// A TradeOpen object represents a Trade for an instrument that was
    /// opened in an Account. It is found embedded in Transactions that affect
    /// the position of an instrument in the Account, specifically the
    /// OrderFill Transaction.
    /// - param TradeOpen
    /// - return OrderFillTransaction
    pub fn with_trade_opened(mut self, x: TradeOpen) -> Self {
        self.trade_opened = Some(x);
        self
    }

    /// The Trades that were closed when the Order was filled (only provided
    /// if filling the Order resulted in a closing open Trades).
    /// - param Vec<TradeReduce>
    /// - return OrderFillTransaction
    pub fn with_trades_closed(mut self, x: Vec<TradeReduce>) -> Self {
        self.trades_closed = Some(x);
        self
    }

    /// A TradeReduce object represents a Trade for an instrument that was
    /// reduced (either partially or fully) in an Account. It is found
    /// embedded in Transactions that affect the position of an instrument in
    /// the account, specifically the OrderFill Transaction.
    /// - param TradeReduce
    /// - return OrderFillTransaction
    pub fn with_trade_reduced(mut self, x: TradeReduce) -> Self {
        self.trade_reduced = Some(x);
        self
    }

    /// The half spread cost for the OrderFill, which is the sum of the
    /// halfSpreadCost values in the tradeOpened, tradesClosed and
    /// tradeReduced fields. This can be a positive or negative value and is
    /// represented in the home currency of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OrderFillTransaction
    pub fn with_half_spread_cost(mut self, x: f32) -> Self {
        self.half_spread_cost = Some(x);
        self
    }
}

/// The reason that an Order was cancelled.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderCancelReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_NEW_POSITIONS_LOCKED")]
    AccountNewPositionsLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_ORDER_FILL_LOCKED")]
    AccountOrderFillLocked,
    #[serde(rename = "CLIENT_REQUEST")]
    ClientRequest,
    #[serde(rename = "MIGRATION")]
    Migration,
    #[serde(rename = "MARKET_HALTED")]
    MarketHalted,
    #[serde(rename = "LINKED_TRADE_CLOSED")]
    LinkedTradeClosed,
    #[serde(rename = "TIME_IN_FORCE_EXPIRED")]
    TimeInForceExpired,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "FIFO_VIOLATION")]
    FifoViolation,
    #[serde(rename = "BOUNDS_VIOLATION")]
    BoundsViolation,
    #[serde(rename = "CLIENT_REQUEST_REPLACED")]
    ClientRequestReplaced,
    #[serde(rename = "INSUFFICIENT_LIQUIDITY")]
    InsufficientLiquidity,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_LOSS")]
    TakeProfitOnFillLoss,
    #[serde(rename = "LOSING_TAKE_PROFIT")]
    LosingTakeProfit,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_LOSS")]
    StopLossOnFillLoss,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED")]
    StopLossOnFillRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOnFillGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TakeProfitOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "POSITION_CLOSEOUT_FAILED")]
    PositionCloseoutFailed,
    #[serde(rename = "OPEN_TRADES_ALLOWED_EXCEEDED")]
    OpenTradesAllowedExceeded,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TakeProfitOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    StopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TrailingStopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "POSITION_SIZE_EXCEEDED")]
    PositionSizeExceeded,
    #[serde(rename = "HEDGING_GSLO_VIOLATION")]
    HedgingGsloViolation,
    #[serde(rename = "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED")]
    AccountPositionValueLimitExceeded,
    #[serde(rename = "INSTRUMENT_BID_REDUCE_ONLY")]
    InstrumentBidReduceOnly,
    #[serde(rename = "INSTRUMENT_ASK_REDUCE_ONLY")]
    InstrumentAskReduceOnly,
    #[serde(rename = "INSTRUMENT_BID_HALTED")]
    InstrumentBidHalted,
    #[serde(rename = "INSTRUMENT_ASK_HALTED")]
    InstrumentAskHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED")]
    StopLossOnFillGuaranteedBidHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED")]
    StopLossOnFillGuaranteedAskHalted,
}

impl FromStr for OrderCancelReason {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderCancelReason, ()> {
        match s {
            "INTERNAL_SERVER_ERROR" => Ok(OrderCancelReason::InternalServerError),
            "ACCOUNT_LOCKED" => Ok(OrderCancelReason::AccountLocked),
            "ACCOUNT_NEW_POSITIONS_LOCKED" => Ok(OrderCancelReason::AccountNewPositionsLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(OrderCancelReason::AccountOrderCreationLocked),
            "ACCOUNT_ORDER_FILL_LOCKED" => Ok(OrderCancelReason::AccountOrderFillLocked),
            "CLIENT_REQUEST" => Ok(OrderCancelReason::ClientRequest),
            "MIGRATION" => Ok(OrderCancelReason::Migration),
            "MARKET_HALTED" => Ok(OrderCancelReason::MarketHalted),
            "LINKED_TRADE_CLOSED" => Ok(OrderCancelReason::LinkedTradeClosed),
            "TIME_IN_FORCE_EXPIRED" => Ok(OrderCancelReason::TimeInForceExpired),
            "INSUFFICIENT_MARGIN" => Ok(OrderCancelReason::InsufficientMargin),
            "FIFO_VIOLATION" => Ok(OrderCancelReason::FifoViolation),
            "BOUNDS_VIOLATION" => Ok(OrderCancelReason::BoundsViolation),
            "CLIENT_REQUEST_REPLACED" => Ok(OrderCancelReason::ClientRequestReplaced),
            "INSUFFICIENT_LIQUIDITY" => Ok(OrderCancelReason::InsufficientLiquidity),
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(OrderCancelReason::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_LOSS" => Ok(OrderCancelReason::TakeProfitOnFillLoss),
            "LOSING_TAKE_PROFIT" => Ok(OrderCancelReason::LosingTakeProfit),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(OrderCancelReason::StopLossOnFillGtdTimestampInPast)
            }
            "STOP_LOSS_ON_FILL_LOSS" => Ok(OrderCancelReason::StopLossOnFillLoss),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(OrderCancelReason::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_REQUIRED" => Ok(OrderCancelReason::StopLossOnFillRequired),
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedRequired)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(OrderCancelReason::StopLossOnFillTimeInForceInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(OrderCancelReason::StopLossOnFillTriggerConditionInvalid)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(OrderCancelReason::TakeProfitOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(OrderCancelReason::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(OrderCancelReason::ClientTradeIdAlreadyExists),
            "POSITION_CLOSEOUT_FAILED" => Ok(OrderCancelReason::PositionCloseoutFailed),
            "OPEN_TRADES_ALLOWED_EXCEEDED" => Ok(OrderCancelReason::OpenTradesAllowedExceeded),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => {
                Ok(OrderCancelReason::PendingOrdersAllowedExceeded)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(OrderCancelReason::TakeProfitOnFillClientOrderIdAlreadyExists)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(OrderCancelReason::StopLossOnFillClientOrderIdAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(OrderCancelReason::TrailingStopLossOnFillClientOrderIdAlreadyExists)
            }
            "POSITION_SIZE_EXCEEDED" => Ok(OrderCancelReason::PositionSizeExceeded),
            "HEDGING_GSLO_VIOLATION" => Ok(OrderCancelReason::HedgingGsloViolation),
            "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED" => {
                Ok(OrderCancelReason::AccountPositionValueLimitExceeded)
            }
            "INSTRUMENT_BID_REDUCE_ONLY" => Ok(OrderCancelReason::InstrumentBidReduceOnly),
            "INSTRUMENT_ASK_REDUCE_ONLY" => Ok(OrderCancelReason::InstrumentAskReduceOnly),
            "INSTRUMENT_BID_HALTED" => Ok(OrderCancelReason::InstrumentBidHalted),
            "INSTRUMENT_ASK_HALTED" => Ok(OrderCancelReason::InstrumentAskHalted),
            "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedBidHalted)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED" => {
                Ok(OrderCancelReason::StopLossOnFillGuaranteedAskHalted)
            }
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderCancelReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderCancelTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "ORDER_CANCEL" for an
    /// OrderCancelTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Order cancelled
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The client ID of the Order cancelled (only provided if the Order has a
    /// client Order ID).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,

    /// The reason that the Order was cancelled.
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled for replacement).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl OrderCancelTransaction {
    pub fn new() -> OrderCancelTransaction {
        OrderCancelTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            order_id: None,
            client_order_id: None,
            reason: None,
            replaced_by_order_id: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderCancelTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return OrderCancelTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "ORDER_CANCEL" for an
    /// OrderCancelTransaction.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Order cancelled
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The client ID of the Order cancelled (only provided if the Order has a
    /// client Order ID).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }

    /// The reason that the Order was cancelled.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled for replacement).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderCancelTransaction
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderCancelRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "ORDER_CANCEL_REJECT" for
    /// an OrderCancelRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Order intended to be cancelled
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The client ID of the Order intended to be cancelled (only provided if
    /// the Order has a client Order ID).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl OrderCancelRejectTransaction {
    pub fn new() -> OrderCancelRejectTransaction {
        OrderCancelRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            order_id: None,
            client_order_id: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderCancelRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return OrderCancelRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "ORDER_CANCEL_REJECT" for
    /// an OrderCancelRejectTransaction.
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Order intended to be cancelled
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The client ID of the Order intended to be cancelled (only provided if
    /// the Order has a client Order ID).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return OrderCancelRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderClientExtensionsModifyTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY" for a
    /// OrderClientExtensionsModifyTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Order who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The original Client ID of the Order who's client extensions are to be
    /// modified.
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "clientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions_modify: Option<ClientExtensions>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
}

impl OrderClientExtensionsModifyTransaction {
    pub fn new() -> OrderClientExtensionsModifyTransaction {
        OrderClientExtensionsModifyTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            order_id: None,
            client_order_id: None,
            client_extensions_modify: None,
            trade_client_extensions_modify: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY" for a
    /// OrderClientExtensionsModifyTransaction.
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Order who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The original Client ID of the Order who's client extensions are to be
    /// modified.
    /// - param String
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.client_extensions_modify = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return OrderClientExtensionsModifyTransaction
    pub fn with_trade_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions_modify = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderClientExtensionsModifyRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// OrderClientExtensionsModifyRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Order who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The original Client ID of the Order who's client extensions are to be
    /// modified.
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "clientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions_modify: Option<ClientExtensions>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl OrderClientExtensionsModifyRejectTransaction {
    pub fn new() -> OrderClientExtensionsModifyRejectTransaction {
        OrderClientExtensionsModifyRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            order_id: None,
            client_order_id: None,
            client_extensions_modify: None,
            trade_client_extensions_modify: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// OrderClientExtensionsModifyRejectTransaction.
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Order who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The original Client ID of the Order who's client extensions are to be
    /// modified.
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.client_extensions_modify = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_trade_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions_modify = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return OrderClientExtensionsModifyRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeClientExtensionsModifyTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY" for a
    /// TradeClientExtensionsModifyTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The original Client ID of the Trade who's client extensions are to be
    /// modified.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
}

impl TradeClientExtensionsModifyTransaction {
    pub fn new() -> TradeClientExtensionsModifyTransaction {
        TradeClientExtensionsModifyTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            trade_client_extensions_modify: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY" for a
    /// TradeClientExtensionsModifyTransaction.
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The original Client ID of the Trade who's client extensions are to be
    /// modified.
    /// - param String
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TradeClientExtensionsModifyTransaction
    pub fn with_trade_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions_modify = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeClientExtensionsModifyRejectTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// TradeClientExtensionsModifyRejectTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The original Client ID of the Trade who's client extensions are to be
    /// modified.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensionsModify",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,

    /// The reason that the Reject Transaction was created
    #[serde(default)]
    #[serde(rename = "rejectReason", skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

impl TradeClientExtensionsModifyRejectTransaction {
    pub fn new() -> TradeClientExtensionsModifyRejectTransaction {
        TradeClientExtensionsModifyRejectTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            trade_client_extensions_modify: None,
            reject_reason: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// TradeClientExtensionsModifyRejectTransaction.
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade who's client extensions are to be modified.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The original Client ID of the Trade who's client extensions are to be
    /// modified.
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_trade_client_extensions_modify(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions_modify = Some(x);
        self
    }

    /// The reason that the Reject Transaction was created
    /// - param String
    /// - return TradeClientExtensionsModifyRejectTransaction
    pub fn with_reject_reason(mut self, x: String) -> Self {
        self.reject_reason = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarginCallEnterTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARGIN_CALL_ENTER" for an
    /// MarginCallEnterTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,
}

impl MarginCallEnterTransaction {
    pub fn new() -> MarginCallEnterTransaction {
        MarginCallEnterTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallEnterTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarginCallEnterTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarginCallEnterTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarginCallEnterTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallEnterTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarginCallEnterTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARGIN_CALL_ENTER" for an
    /// MarginCallEnterTransaction.
    /// - param String
    /// - return MarginCallEnterTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarginCallExtendTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARGIN_CALL_EXTEND" for an
    /// MarginCallExtendTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The number of the extensions to the Account's current margin call that
    /// have been applied. This value will be set to 1 for the first
    /// MarginCallExtend Transaction
    #[serde(default)]
    #[serde(rename = "extensionNumber", skip_serializing_if = "Option::is_none")]
    pub extension_number: Option<i32>,
}

impl MarginCallExtendTransaction {
    pub fn new() -> MarginCallExtendTransaction {
        MarginCallExtendTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            extension_number: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallExtendTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarginCallExtendTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarginCallExtendTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarginCallExtendTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallExtendTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarginCallExtendTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARGIN_CALL_EXTEND" for an
    /// MarginCallExtendTransaction.
    /// - param String
    /// - return MarginCallExtendTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The number of the extensions to the Account's current margin call that
    /// have been applied. This value will be set to 1 for the first
    /// MarginCallExtend Transaction
    /// - param i32
    /// - return MarginCallExtendTransaction
    pub fn with_extension_number(mut self, x: i32) -> Self {
        self.extension_number = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarginCallExitTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "MARGIN_CALL_EXIT" for an
    /// MarginCallExitTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,
}

impl MarginCallExitTransaction {
    pub fn new() -> MarginCallExitTransaction {
        MarginCallExitTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallExitTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarginCallExitTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return MarginCallExitTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return MarginCallExitTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarginCallExitTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return MarginCallExitTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "MARGIN_CALL_EXIT" for an
    /// MarginCallExitTransaction.
    /// - param String
    /// - return MarginCallExitTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DelayedTradeClosureTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "DELAYED_TRADE_CLOSURE" for
    /// an DelayedTradeClosureTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The reason for the delayed trade closure
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// List of Trade ID's identifying the open trades that will be closed
    /// when their respective instruments become tradeable
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeIDs", skip_serializing_if = "Option::is_none")]
    pub trade_i_ds: Option<String>,
}

impl DelayedTradeClosureTransaction {
    pub fn new() -> DelayedTradeClosureTransaction {
        DelayedTradeClosureTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            reason: None,
            trade_i_ds: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return DelayedTradeClosureTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return DelayedTradeClosureTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "DELAYED_TRADE_CLOSURE" for
    /// an DelayedTradeClosureTransaction.
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The reason for the delayed trade closure
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }

    /// List of Trade ID's identifying the open trades that will be closed
    /// when their respective instruments become tradeable
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return DelayedTradeClosureTransaction
    pub fn with_trade_i_ds(mut self, x: String) -> Self {
        self.trade_i_ds = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DailyFinancingTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "DAILY_FINANCING" for a
    /// DailyFinancingTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The amount of financing paid/collected for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The Account's balance after daily financing.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "accountBalance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub account_balance: Option<f32>,

    /// The account financing mode at the time of the daily financing.
    #[serde(default)]
    #[serde(
        rename = "accountFinancingMode",
        skip_serializing_if = "Option::is_none"
    )]
    pub account_financing_mode: Option<String>,

    /// The financing paid/collected for each Position in the Account.
    #[serde(default)]
    #[serde(rename = "positionFinancings", skip_serializing_if = "Option::is_none")]
    pub position_financings: Option<Vec<PositionFinancing>>,
}

impl DailyFinancingTransaction {
    pub fn new() -> DailyFinancingTransaction {
        DailyFinancingTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
            financing: None,
            account_balance: None,
            account_financing_mode: None,
            position_financings: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return DailyFinancingTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return DailyFinancingTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "DAILY_FINANCING" for a
    /// DailyFinancingTransaction.
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The amount of financing paid/collected for the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return DailyFinancingTransaction
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The Account's balance after daily financing.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return DailyFinancingTransaction
    pub fn with_account_balance(mut self, x: f32) -> Self {
        self.account_balance = Some(x);
        self
    }

    /// The account financing mode at the time of the daily financing.
    /// - param String
    /// - return DailyFinancingTransaction
    pub fn with_account_financing_mode(mut self, x: String) -> Self {
        self.account_financing_mode = Some(x);
        self
    }

    /// The financing paid/collected for each Position in the Account.
    /// - param Vec<PositionFinancing>
    /// - return DailyFinancingTransaction
    pub fn with_position_financings(mut self, x: Vec<PositionFinancing>) -> Self {
        self.position_financings = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResetResettablePLTransaction {
    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// The ID of the user that initiated the creation of the Transaction.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    #[serde(default)]
    #[serde(rename = "accountID", skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "batchID", skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,

    /// The Request ID of the request which generated the transaction.
    #[serde(default)]
    #[serde(rename = "requestID", skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// The Type of the Transaction. Always set to "RESET_RESETTABLE_PL" for a
    /// ResetResettablePLTransaction.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,
}

impl ResetResettablePLTransaction {
    pub fn new() -> ResetResettablePLTransaction {
        ResetResettablePLTransaction {
            id: None,
            time: None,
            user_id: None,
            account_id: None,
            batch_id: None,
            request_id: None,
            otype: None,
        }
    }

    /// The Transaction's Identifier.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ResetResettablePLTransaction
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The date/time when the Transaction was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return ResetResettablePLTransaction
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// The ID of the user that initiated the creation of the Transaction.
    /// - param i32
    /// - return ResetResettablePLTransaction
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The ID of the Account the Transaction was created for.
    /// format: "-"-delimited string with format
    /// "{siteID}-{divisionID}-{userID}-{accountNumber}"
    /// - param String
    /// - return ResetResettablePLTransaction
    pub fn with_account_id(mut self, x: String) -> Self {
        self.account_id = Some(x);
        self
    }

    /// The ID of the "batch" that the Transaction belongs to. Transactions in
    /// the same batch are applied to the Account simultaneously.
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return ResetResettablePLTransaction
    pub fn with_batch_id(mut self, x: String) -> Self {
        self.batch_id = Some(x);
        self
    }

    /// The Request ID of the request which generated the transaction.
    /// - param String
    /// - return ResetResettablePLTransaction
    pub fn with_request_id(mut self, x: String) -> Self {
        self.request_id = Some(x);
        self
    }

    /// The Type of the Transaction. Always set to "RESET_RESETTABLE_PL" for a
    /// ResetResettablePLTransaction.
    /// - param String
    /// - return ResetResettablePLTransaction
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ClientExtensions {
    /// The Client ID of the Order/Trade
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// A tag associated with the Order/Trade
    #[serde(default)]
    #[serde(rename = "tag", skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,

    /// A comment associated with the Order/Trade
    #[serde(default)]
    #[serde(rename = "comment", skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}

impl ClientExtensions {
    pub fn new() -> ClientExtensions {
        ClientExtensions {
            id: None,
            tag: None,
            comment: None,
        }
    }

    /// The Client ID of the Order/Trade
    /// - param String
    /// - return ClientExtensions
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// A tag associated with the Order/Trade
    /// - param String
    /// - return ClientExtensions
    pub fn with_tag(mut self, x: String) -> Self {
        self.tag = Some(x);
        self
    }

    /// A comment associated with the Order/Trade
    /// - param String
    /// - return ClientExtensions
    pub fn with_comment(mut self, x: String) -> Self {
        self.comment = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TakeProfitDetails {
    /// The price that the Take Profit Order will be triggered at. Only one of
    /// the price and distance fields may be specified.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time in force for the created Take Profit Order. This may only be
    /// GTC, GTD or GFD.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date when the Take Profit Order will be cancelled on if
    /// timeInForce is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl TakeProfitDetails {
    pub fn new() -> TakeProfitDetails {
        TakeProfitDetails {
            price: None,
            time_in_force: None,
            gtd_time: None,
            client_extensions: None,
        }
    }

    /// The price that the Take Profit Order will be triggered at. Only one of
    /// the price and distance fields may be specified.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TakeProfitDetails
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time in force for the created Take Profit Order. This may only be
    /// GTC, GTD or GFD.
    /// - param String
    /// - return TakeProfitDetails
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date when the Take Profit Order will be cancelled on if
    /// timeInForce is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitDetails
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TakeProfitDetails
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopLossDetails {
    /// The price that the Stop Loss Order will be triggered at. Only one of
    /// the price and distance fields may be specified.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specifies the distance (in price units) from the Trade's open price to
    /// use as the Stop Loss Order price. Only one of the distance and price
    /// fields may be specified.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time in force for the created Stop Loss Order. This may only be
    /// GTC, GTD or GFD.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date when the Stop Loss Order will be cancelled on if timeInForce
    /// is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// Flag indicating that the price for the Stop Loss Order is guaranteed.
    /// The default value depends on the GuaranteedStopLossOrderMode of the
    /// account, if it is REQUIRED, the default will be true, for DISABLED or
    /// ENABLED the default is false.
    #[serde(default)]
    #[serde(rename = "guaranteed", skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
}

impl StopLossDetails {
    pub fn new() -> StopLossDetails {
        StopLossDetails {
            price: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            client_extensions: None,
            guaranteed: None,
        }
    }

    /// The price that the Stop Loss Order will be triggered at. Only one of
    /// the price and distance fields may be specified.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopLossDetails
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specifies the distance (in price units) from the Trade's open price to
    /// use as the Stop Loss Order price. Only one of the distance and price
    /// fields may be specified.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossDetails
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time in force for the created Stop Loss Order. This may only be
    /// GTC, GTD or GFD.
    /// - param String
    /// - return StopLossDetails
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date when the Stop Loss Order will be cancelled on if timeInForce
    /// is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossDetails
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopLossDetails
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// Flag indicating that the price for the Stop Loss Order is guaranteed.
    /// The default value depends on the GuaranteedStopLossOrderMode of the
    /// account, if it is REQUIRED, the default will be true, for DISABLED or
    /// ENABLED the default is false.
    /// - param bool
    /// - return StopLossDetails
    pub fn with_guaranteed(mut self, x: bool) -> Self {
        self.guaranteed = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrailingStopLossDetails {
    /// The distance (in price units) from the Trade's fill price that the
    /// Trailing Stop Loss Order will be triggered at.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time in force for the created Trailing Stop Loss Order. This may
    /// only be GTC, GTD or GFD.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date when the Trailing Stop Loss Order will be cancelled on if
    /// timeInForce is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl TrailingStopLossDetails {
    pub fn new() -> TrailingStopLossDetails {
        TrailingStopLossDetails {
            distance: None,
            time_in_force: None,
            gtd_time: None,
            client_extensions: None,
        }
    }

    /// The distance (in price units) from the Trade's fill price that the
    /// Trailing Stop Loss Order will be triggered at.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TrailingStopLossDetails
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time in force for the created Trailing Stop Loss Order. This may
    /// only be GTC, GTD or GFD.
    /// - param String
    /// - return TrailingStopLossDetails
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date when the Trailing Stop Loss Order will be cancelled on if
    /// timeInForce is GTD.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossDetails
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TrailingStopLossDetails
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeOpen {
    /// The ID of the Trade that was opened
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The number of units opened by the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The average price that the units were opened at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// This is the fee charged for opening the trade if it has a guaranteed
    /// Stop Loss Order attached to it.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFee",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fee: Option<f32>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The half spread cost for the trade open. This can be a positive or
    /// negative value and is represented in the home currency of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "halfSpreadCost",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub half_spread_cost: Option<f32>,

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "initialMarginRequired",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_margin_required: Option<f32>,
}

impl TradeOpen {
    pub fn new() -> TradeOpen {
        TradeOpen {
            trade_id: None,
            units: None,
            price: None,
            guaranteed_execution_fee: None,
            client_extensions: None,
            half_spread_cost: None,
            initial_margin_required: None,
        }
    }

    /// The ID of the Trade that was opened
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TradeOpen
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The number of units opened by the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TradeOpen
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The average price that the units were opened at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TradeOpen
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// This is the fee charged for opening the trade if it has a guaranteed
    /// Stop Loss Order attached to it.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeOpen
    pub fn with_guaranteed_execution_fee(mut self, x: f32) -> Self {
        self.guaranteed_execution_fee = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TradeOpen
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The half spread cost for the trade open. This can be a positive or
    /// negative value and is represented in the home currency of the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeOpen
    pub fn with_half_spread_cost(mut self, x: f32) -> Self {
        self.half_spread_cost = Some(x);
        self
    }

    /// The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used that
    /// factors in the trade risk if a GSLO is attached to the trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeOpen
    pub fn with_initial_margin_required(mut self, x: f32) -> Self {
        self.initial_margin_required = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeReduce {
    /// The ID of the Trade that was reduced or closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The number of units that the Trade was reduced by
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The average price that the units were closed at. This price may be
    /// clamped for guaranteed Stop Loss Orders.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The PL realized when reducing the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "realizedPL",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub realized_pl: Option<f32>,

    /// The financing paid/collected when reducing the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// This is the fee that is charged for closing the Trade if it has a
    /// guaranteed Stop Loss Order attached to it.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionFee",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_fee: Option<f32>,

    /// The half spread cost for the trade reduce/close. This can be a
    /// positive or negative value and is represented in the home currency of
    /// the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "halfSpreadCost",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub half_spread_cost: Option<f32>,
}

impl TradeReduce {
    pub fn new() -> TradeReduce {
        TradeReduce {
            trade_id: None,
            units: None,
            price: None,
            realized_pl: None,
            financing: None,
            guaranteed_execution_fee: None,
            half_spread_cost: None,
        }
    }

    /// The ID of the Trade that was reduced or closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TradeReduce
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The number of units that the Trade was reduced by
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TradeReduce
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The average price that the units were closed at. This price may be
    /// clamped for guaranteed Stop Loss Orders.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TradeReduce
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The PL realized when reducing the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeReduce
    pub fn with_realized_pl(mut self, x: f32) -> Self {
        self.realized_pl = Some(x);
        self
    }

    /// The financing paid/collected when reducing the Trade
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeReduce
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// This is the fee that is charged for closing the Trade if it has a
    /// guaranteed Stop Loss Order attached to it.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeReduce
    pub fn with_guaranteed_execution_fee(mut self, x: f32) -> Self {
        self.guaranteed_execution_fee = Some(x);
        self
    }

    /// The half spread cost for the trade reduce/close. This can be a
    /// positive or negative value and is represented in the home currency of
    /// the Account.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return TradeReduce
    pub fn with_half_spread_cost(mut self, x: f32) -> Self {
        self.half_spread_cost = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderTradeClose {
    /// The ID of the Trade requested to be closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade requested to be closed
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// Indication of how much of the Trade to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade.
    #[serde(default)]
    #[serde(rename = "units", skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl MarketOrderTradeClose {
    pub fn new() -> MarketOrderTradeClose {
        MarketOrderTradeClose {
            trade_id: None,
            client_trade_id: None,
            units: None,
        }
    }

    /// The ID of the Trade requested to be closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketOrderTradeClose
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade requested to be closed
    /// - param String
    /// - return MarketOrderTradeClose
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// Indication of how much of the Trade to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade.
    /// - param String
    /// - return MarketOrderTradeClose
    pub fn with_units(mut self, x: String) -> Self {
        self.units = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderMarginCloseout {
    /// The reason the Market Order was created to perform a margin closeout
    #[serde(default)]
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl MarketOrderMarginCloseout {
    pub fn new() -> MarketOrderMarginCloseout {
        MarketOrderMarginCloseout { reason: None }
    }

    /// The reason the Market Order was created to perform a margin closeout
    /// - param String
    /// - return MarketOrderMarginCloseout
    pub fn with_reason(mut self, x: String) -> Self {
        self.reason = Some(x);
        self
    }
}

/// The reason that the Market Order was created to perform a margin
/// closeout
#[derive(Debug, Serialize, Deserialize)]
pub enum MarketOrderMarginCloseoutReason {
    #[serde(rename = "MARGIN_CHECK_VIOLATION")]
    MarginCheckViolation,
    #[serde(rename = "REGULATORY_MARGIN_CALL_VIOLATION")]
    RegulatoryMarginCallViolation,
    #[serde(rename = "REGULATORY_MARGIN_CHECK_VIOLATION")]
    RegulatoryMarginCheckViolation,
}

impl FromStr for MarketOrderMarginCloseoutReason {
    type Err = ();
    fn from_str(s: &str) -> Result<MarketOrderMarginCloseoutReason, ()> {
        match s {
            "MARGIN_CHECK_VIOLATION" => Ok(MarketOrderMarginCloseoutReason::MarginCheckViolation),
            "REGULATORY_MARGIN_CALL_VIOLATION" => {
                Ok(MarketOrderMarginCloseoutReason::RegulatoryMarginCallViolation)
            }
            "REGULATORY_MARGIN_CHECK_VIOLATION" => {
                Ok(MarketOrderMarginCloseoutReason::RegulatoryMarginCheckViolation)
            }
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for MarketOrderMarginCloseoutReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderDelayedTradeClose {
    /// The ID of the Trade being closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The Client ID of the Trade being closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The Transaction ID of the DelayedTradeClosure transaction to which
    /// this Delayed Trade Close belongs to
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "sourceTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub source_transaction_id: Option<String>,
}

impl MarketOrderDelayedTradeClose {
    pub fn new() -> MarketOrderDelayedTradeClose {
        MarketOrderDelayedTradeClose {
            trade_id: None,
            client_trade_id: None,
            source_transaction_id: None,
        }
    }

    /// The ID of the Trade being closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketOrderDelayedTradeClose
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The Client ID of the Trade being closed
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketOrderDelayedTradeClose
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The Transaction ID of the DelayedTradeClosure transaction to which
    /// this Delayed Trade Close belongs to
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrderDelayedTradeClose
    pub fn with_source_transaction_id(mut self, x: String) -> Self {
        self.source_transaction_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderPositionCloseout {
    /// The instrument of the Position being closed out.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// Indication of how much of the Position to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade. The
    /// DecimalNumber must always be positive, and represent a number that
    /// doesn't exceed the absolute size of the Position.
    #[serde(default)]
    #[serde(rename = "units", skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl MarketOrderPositionCloseout {
    pub fn new() -> MarketOrderPositionCloseout {
        MarketOrderPositionCloseout {
            instrument: None,
            units: None,
        }
    }

    /// The instrument of the Position being closed out.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketOrderPositionCloseout
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// Indication of how much of the Position to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade. The
    /// DecimalNumber must always be positive, and represent a number that
    /// doesn't exceed the absolute size of the Position.
    /// - param String
    /// - return MarketOrderPositionCloseout
    pub fn with_units(mut self, x: String) -> Self {
        self.units = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LiquidityRegenerationSchedule {
    /// The steps in the Liquidity Regeneration Schedule
    #[serde(default)]
    #[serde(rename = "steps", skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<LiquidityRegenerationScheduleStep>>,
}

impl LiquidityRegenerationSchedule {
    pub fn new() -> LiquidityRegenerationSchedule {
        LiquidityRegenerationSchedule { steps: None }
    }

    /// The steps in the Liquidity Regeneration Schedule
    /// - param Vec<LiquidityRegenerationScheduleStep>
    /// - return LiquidityRegenerationSchedule
    pub fn with_steps(mut self, x: Vec<LiquidityRegenerationScheduleStep>) -> Self {
        self.steps = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LiquidityRegenerationScheduleStep {
    /// The timestamp of the schedule step.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "timestamp",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub timestamp: Option<DateTime<Utc>>,

    /// The amount of bid liquidity used at this step in the schedule.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "bidLiquidityUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub bid_liquidity_used: Option<f32>,

    /// The amount of ask liquidity used at this step in the schedule.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "askLiquidityUsed",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub ask_liquidity_used: Option<f32>,
}

impl LiquidityRegenerationScheduleStep {
    pub fn new() -> LiquidityRegenerationScheduleStep {
        LiquidityRegenerationScheduleStep {
            timestamp: None,
            bid_liquidity_used: None,
            ask_liquidity_used: None,
        }
    }

    /// The timestamp of the schedule step.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LiquidityRegenerationScheduleStep
    pub fn with_timestamp(mut self, x: DateTime<Utc>) -> Self {
        self.timestamp = Some(x);
        self
    }

    /// The amount of bid liquidity used at this step in the schedule.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LiquidityRegenerationScheduleStep
    pub fn with_bid_liquidity_used(mut self, x: f32) -> Self {
        self.bid_liquidity_used = Some(x);
        self
    }

    /// The amount of ask liquidity used at this step in the schedule.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LiquidityRegenerationScheduleStep
    pub fn with_ask_liquidity_used(mut self, x: f32) -> Self {
        self.ask_liquidity_used = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OpenTradeFinancing {
    /// The ID of the Trade that financing is being paid/collected for.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The amount of financing paid/collected for the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,
}

impl OpenTradeFinancing {
    pub fn new() -> OpenTradeFinancing {
        OpenTradeFinancing {
            trade_id: None,
            financing: None,
        }
    }

    /// The ID of the Trade that financing is being paid/collected for.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return OpenTradeFinancing
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The amount of financing paid/collected for the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return OpenTradeFinancing
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PositionFinancing {
    /// The instrument of the Position that financing is being paid/collected
    /// for.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The amount of financing paid/collected for the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    #[serde(default)]
    #[serde(
        rename = "financing",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub financing: Option<f32>,

    /// The financing paid/collect for each open Trade within the Position.
    #[serde(default)]
    #[serde(
        rename = "openTradeFinancings",
        skip_serializing_if = "Option::is_none"
    )]
    pub open_trade_financings: Option<Vec<OpenTradeFinancing>>,
}

impl PositionFinancing {
    pub fn new() -> PositionFinancing {
        PositionFinancing {
            instrument: None,
            financing: None,
            open_trade_financings: None,
        }
    }

    /// The instrument of the Position that financing is being paid/collected
    /// for.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return PositionFinancing
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The amount of financing paid/collected for the Position.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on the Account's home currency.
    /// - param f32
    /// - return PositionFinancing
    pub fn with_financing(mut self, x: f32) -> Self {
        self.financing = Some(x);
        self
    }

    /// The financing paid/collect for each open Trade within the Position.
    /// - param Vec<OpenTradeFinancing>
    /// - return PositionFinancing
    pub fn with_open_trade_financings(mut self, x: Vec<OpenTradeFinancing>) -> Self {
        self.open_trade_financings = Some(x);
        self
    }
}

/// The reason that a Transaction was rejected.
#[derive(Debug, Serialize, Deserialize)]
pub enum TransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl FromStr for TransactionRejectReason {
    type Err = ();
    fn from_str(s: &str) -> Result<TransactionRejectReason, ()> {
        match s {
            "INTERNAL_SERVER_ERROR" => Ok(TransactionRejectReason::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(TransactionRejectReason::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(TransactionRejectReason::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(TransactionRejectReason::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => {
                Ok(TransactionRejectReason::AccountOrderCreationLocked)
            }
            "ACCOUNT_CONFIGURATION_LOCKED" => {
                Ok(TransactionRejectReason::AccountConfigurationLocked)
            }
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(TransactionRejectReason::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(TransactionRejectReason::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(TransactionRejectReason::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(TransactionRejectReason::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => {
                Ok(TransactionRejectReason::PendingOrdersAllowedExceeded)
            }
            "ORDER_ID_UNSPECIFIED" => Ok(TransactionRejectReason::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(TransactionRejectReason::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => {
                Ok(TransactionRejectReason::OrderIdentifierInconsistency)
            }
            "TRADE_ID_UNSPECIFIED" => Ok(TransactionRejectReason::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(TransactionRejectReason::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => {
                Ok(TransactionRejectReason::TradeIdentifierInconsistency)
            }
            "INSUFFICIENT_MARGIN" => Ok(TransactionRejectReason::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(TransactionRejectReason::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(TransactionRejectReason::InstrumentUnknown),
            "UNITS_MISSING" => Ok(TransactionRejectReason::UnitsMissing),
            "UNITS_INVALID" => Ok(TransactionRejectReason::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(TransactionRejectReason::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(TransactionRejectReason::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(TransactionRejectReason::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(TransactionRejectReason::PriceMissing),
            "PRICE_INVALID" => Ok(TransactionRejectReason::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(TransactionRejectReason::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(TransactionRejectReason::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(TransactionRejectReason::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::PriceDistancePrecisionExceeded)
            }
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(TransactionRejectReason::PriceDistanceMaximumExceeded)
            }
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(TransactionRejectReason::PriceDistanceMinimumNotMet)
            }
            "TIME_IN_FORCE_MISSING" => Ok(TransactionRejectReason::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(TransactionRejectReason::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => {
                Ok(TransactionRejectReason::TimeInForceGtdTimestampMissing)
            }
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => {
                Ok(TransactionRejectReason::TimeInForceGtdTimestampInPast)
            }
            "PRICE_BOUND_INVALID" => Ok(TransactionRejectReason::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::PriceBoundPrecisionExceeded)
            }
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(TransactionRejectReason::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(TransactionRejectReason::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(TransactionRejectReason::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(TransactionRejectReason::ClientOrderIdAlreadyExists)
            }
            "CLIENT_ORDER_TAG_INVALID" => Ok(TransactionRejectReason::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(TransactionRejectReason::ClientOrderCommentInvalid)
            }
            "CLIENT_TRADE_ID_INVALID" => Ok(TransactionRejectReason::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => {
                Ok(TransactionRejectReason::ClientTradeIdAlreadyExists)
            }
            "CLIENT_TRADE_TAG_INVALID" => Ok(TransactionRejectReason::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => {
                Ok(TransactionRejectReason::ClientTradeCommentInvalid)
            }
            "ORDER_FILL_POSITION_ACTION_MISSING" => {
                Ok(TransactionRejectReason::OrderFillPositionActionMissing)
            }
            "ORDER_FILL_POSITION_ACTION_INVALID" => {
                Ok(TransactionRejectReason::OrderFillPositionActionInvalid)
            }
            "TRIGGER_CONDITION_MISSING" => Ok(TransactionRejectReason::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(TransactionRejectReason::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => {
                Ok(TransactionRejectReason::OrderPartialFillOptionMissing)
            }
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => {
                Ok(TransactionRejectReason::OrderPartialFillOptionInvalid)
            }
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(TransactionRejectReason::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => {
                Ok(TransactionRejectReason::TakeProfitOrderAlreadyExists)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => {
                Ok(TransactionRejectReason::TakeProfitOnFillPriceMissing)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillPriceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(TransactionRejectReason::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(TransactionRejectReason::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(TransactionRejectReason::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(TransactionRejectReason::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(TransactionRejectReason::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(TransactionRejectReason::StopLossOrderAlreadyExists)
            }
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedRequired)
            }
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => {
                Ok(TransactionRejectReason::StopLossOrderNotCancelable)
            }
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => {
                Ok(TransactionRejectReason::StopLossOrderNotReplaceable)
            }
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(TransactionRejectReason::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(TransactionRejectReason::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(TransactionRejectReason::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(TransactionRejectReason::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(TransactionRejectReason::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => {
                Ok(TransactionRejectReason::StopLossOnFillGuaranteedRequired)
            }
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => {
                Ok(TransactionRejectReason::StopLossOnFillPriceMissing)
            }
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillPriceInvalid)
            }
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(TransactionRejectReason::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(TransactionRejectReason::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillDistanceInvalid)
            }
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(TransactionRejectReason::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(TransactionRejectReason::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(TransactionRejectReason::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(TransactionRejectReason::StopLossOnFillTimeInForceMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillTimeInForceInvalid)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(TransactionRejectReason::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(TransactionRejectReason::StopLossOnFillGtdTimestampInPast)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(TransactionRejectReason::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(TransactionRejectReason::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(TransactionRejectReason::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(TransactionRejectReason::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(TransactionRejectReason::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(TransactionRejectReason::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => {
                Ok(TransactionRejectReason::CloseTradePartialUnitsMissing)
            }
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => {
                Ok(TransactionRejectReason::CloseTradeUnitsExceedTradeSize)
            }
            "CLOSEOUT_POSITION_DOESNT_EXIST" => {
                Ok(TransactionRejectReason::CloseoutPositionDoesntExist)
            }
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(TransactionRejectReason::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(TransactionRejectReason::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(TransactionRejectReason::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(TransactionRejectReason::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(TransactionRejectReason::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => {
                Ok(TransactionRejectReason::PositionAggregationModeInvalid)
            }
            "ADMIN_CONFIGURE_DATA_MISSING" => {
                Ok(TransactionRejectReason::AdminConfigureDataMissing)
            }
            "MARGIN_RATE_INVALID" => Ok(TransactionRejectReason::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => {
                Ok(TransactionRejectReason::MarginRateWouldTriggerCloseout)
            }
            "ALIAS_INVALID" => Ok(TransactionRejectReason::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => {
                Ok(TransactionRejectReason::ClientConfigureDataMissing)
            }
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => {
                Ok(TransactionRejectReason::MarginRateWouldTriggerMarginCall)
            }
            "AMOUNT_INVALID" => Ok(TransactionRejectReason::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(TransactionRejectReason::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(TransactionRejectReason::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(TransactionRejectReason::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => {
                Ok(TransactionRejectReason::ClientExtensionsDataMissing)
            }
            "REPLACING_ORDER_INVALID" => Ok(TransactionRejectReason::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(TransactionRejectReason::ReplacingTradeIdInvalid),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TransactionRejectReason {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// A filter that can be used when fetching Transactions
#[derive(Debug, Serialize, Deserialize)]
pub enum TransactionFilter {
    #[serde(rename = "ORDER")]
    Order,
    #[serde(rename = "FUNDING")]
    Funding,
    #[serde(rename = "ADMIN")]
    Admin,
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER")]
    OneCancelsAllOrder,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_REJECT")]
    OneCancelsAllOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_TRIGGERED")]
    OneCancelsAllOrderTriggered,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl FromStr for TransactionFilter {
    type Err = ();
    fn from_str(s: &str) -> Result<TransactionFilter, ()> {
        match s {
            "ORDER" => Ok(TransactionFilter::Order),
            "FUNDING" => Ok(TransactionFilter::Funding),
            "ADMIN" => Ok(TransactionFilter::Admin),
            "CREATE" => Ok(TransactionFilter::Create),
            "CLOSE" => Ok(TransactionFilter::Close),
            "REOPEN" => Ok(TransactionFilter::Reopen),
            "CLIENT_CONFIGURE" => Ok(TransactionFilter::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(TransactionFilter::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(TransactionFilter::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(TransactionFilter::TransferFundsReject),
            "MARKET_ORDER" => Ok(TransactionFilter::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(TransactionFilter::MarketOrderReject),
            "LIMIT_ORDER" => Ok(TransactionFilter::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(TransactionFilter::LimitOrderReject),
            "STOP_ORDER" => Ok(TransactionFilter::StopOrder),
            "STOP_ORDER_REJECT" => Ok(TransactionFilter::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(TransactionFilter::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(TransactionFilter::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(TransactionFilter::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(TransactionFilter::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(TransactionFilter::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(TransactionFilter::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(TransactionFilter::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(TransactionFilter::TrailingStopLossOrderReject),
            "ONE_CANCELS_ALL_ORDER" => Ok(TransactionFilter::OneCancelsAllOrder),
            "ONE_CANCELS_ALL_ORDER_REJECT" => Ok(TransactionFilter::OneCancelsAllOrderReject),
            "ONE_CANCELS_ALL_ORDER_TRIGGERED" => Ok(TransactionFilter::OneCancelsAllOrderTriggered),
            "ORDER_FILL" => Ok(TransactionFilter::OrderFill),
            "ORDER_CANCEL" => Ok(TransactionFilter::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(TransactionFilter::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(TransactionFilter::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => {
                Ok(TransactionFilter::OrderClientExtensionsModifyReject)
            }
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(TransactionFilter::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => {
                Ok(TransactionFilter::TradeClientExtensionsModifyReject)
            }
            "MARGIN_CALL_ENTER" => Ok(TransactionFilter::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(TransactionFilter::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(TransactionFilter::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(TransactionFilter::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(TransactionFilter::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(TransactionFilter::ResetResettablePl),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TransactionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionHeartbeat {
    /// The string "HEARTBEAT"
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the most recent Transaction created for the Account
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(rename = "lastTransactionID", skip_serializing_if = "Option::is_none")]
    pub last_transaction_id: Option<String>,

    /// The date/time when the TransactionHeartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,
}

impl TransactionHeartbeat {
    pub fn new() -> TransactionHeartbeat {
        TransactionHeartbeat {
            otype: None,
            last_transaction_id: None,
            time: None,
        }
    }

    /// The string "HEARTBEAT"
    /// - param String
    /// - return TransactionHeartbeat
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the most recent Transaction created for the Account
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TransactionHeartbeat
    pub fn with_last_transaction_id(mut self, x: String) -> Self {
        self.last_transaction_id = Some(x);
        self
    }

    /// The date/time when the TransactionHeartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TransactionHeartbeat
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserInfo {
    /// The user-provided username.
    #[serde(default)]
    #[serde(rename = "username", skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,

    /// The user's OANDA-assigned user ID.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The country that the user is based in.
    #[serde(default)]
    #[serde(rename = "country", skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,

    /// The user's email address.
    #[serde(default)]
    #[serde(rename = "emailAddress", skip_serializing_if = "Option::is_none")]
    pub email_address: Option<String>,
}

impl UserInfo {
    pub fn new() -> UserInfo {
        UserInfo {
            username: None,
            user_id: None,
            country: None,
            email_address: None,
        }
    }

    /// The user-provided username.
    /// - param String
    /// - return UserInfo
    pub fn with_username(mut self, x: String) -> Self {
        self.username = Some(x);
        self
    }

    /// The user's OANDA-assigned user ID.
    /// - param i32
    /// - return UserInfo
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The country that the user is based in.
    /// - param String
    /// - return UserInfo
    pub fn with_country(mut self, x: String) -> Self {
        self.country = Some(x);
        self
    }

    /// The user's email address.
    /// - param String
    /// - return UserInfo
    pub fn with_email_address(mut self, x: String) -> Self {
        self.email_address = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserInfoExternal {
    /// The user's OANDA-assigned user ID.
    #[serde(default)]
    #[serde(rename = "userID", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i32>,

    /// The country that the user is based in.
    #[serde(default)]
    #[serde(rename = "country", skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,

    /// Flag indicating if the the user's Accounts adhere to FIFO execution
    /// rules.
    #[serde(default)]
    #[serde(rename = "FIFO", skip_serializing_if = "Option::is_none")]
    pub fifo: Option<bool>,
}

impl UserInfoExternal {
    pub fn new() -> UserInfoExternal {
        UserInfoExternal {
            user_id: None,
            country: None,
            fifo: None,
        }
    }

    /// The user's OANDA-assigned user ID.
    /// - param i32
    /// - return UserInfoExternal
    pub fn with_user_id(mut self, x: i32) -> Self {
        self.user_id = Some(x);
        self
    }

    /// The country that the user is based in.
    /// - param String
    /// - return UserInfoExternal
    pub fn with_country(mut self, x: String) -> Self {
        self.country = Some(x);
        self
    }

    /// Flag indicating if the the user's Accounts adhere to FIFO execution
    /// rules.
    /// - param bool
    /// - return UserInfoExternal
    pub fn with_fifo(mut self, x: bool) -> Self {
        self.fifo = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ClientPrice {
    /// The string "PRICE". Used to identify the a Price object when found in
    /// a stream.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Price's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The date/time when the Price was created
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,

    /// Flag indicating if the Price is tradeable or not
    #[serde(default)]
    #[serde(rename = "tradeable", skip_serializing_if = "Option::is_none")]
    pub tradeable: Option<bool>,

    /// The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default)]
    #[serde(rename = "bids", skip_serializing_if = "Option::is_none")]
    pub bids: Option<Vec<PriceBucket>>,

    /// The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default)]
    #[serde(rename = "asks", skip_serializing_if = "Option::is_none")]
    pub asks: Option<Vec<PriceBucket>>,

    /// The closeout bid Price. This Price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "closeoutBid",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub closeout_bid: Option<f32>,

    /// The closeout ask Price. This Price is used when a ask is required to
    /// closeout a Position (margin closeout or manual) yet there is no ask
    /// liquidity. The closeout ask is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "closeoutAsk",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub closeout_ask: Option<f32>,
}

impl ClientPrice {
    pub fn new() -> ClientPrice {
        ClientPrice {
            otype: None,
            instrument: None,
            time: None,
            tradeable: None,
            bids: None,
            asks: None,
            closeout_bid: None,
            closeout_ask: None,
        }
    }

    /// The string "PRICE". Used to identify the a Price object when found in
    /// a stream.
    /// - param String
    /// - return ClientPrice
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Price's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return ClientPrice
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The date/time when the Price was created
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return ClientPrice
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }

    /// Flag indicating if the Price is tradeable or not
    /// - param bool
    /// - return ClientPrice
    pub fn with_tradeable(mut self, x: bool) -> Self {
        self.tradeable = Some(x);
        self
    }

    /// The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    /// - param Vec<PriceBucket>
    /// - return ClientPrice
    pub fn with_bids(mut self, x: Vec<PriceBucket>) -> Self {
        self.bids = Some(x);
        self
    }

    /// The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    /// - param Vec<PriceBucket>
    /// - return ClientPrice
    pub fn with_asks(mut self, x: Vec<PriceBucket>) -> Self {
        self.asks = Some(x);
        self
    }

    /// The closeout bid Price. This Price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return ClientPrice
    pub fn with_closeout_bid(mut self, x: f32) -> Self {
        self.closeout_bid = Some(x);
        self
    }

    /// The closeout ask Price. This Price is used when a ask is required to
    /// closeout a Position (margin closeout or manual) yet there is no ask
    /// liquidity. The closeout ask is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return ClientPrice
    pub fn with_closeout_ask(mut self, x: f32) -> Self {
        self.closeout_ask = Some(x);
        self
    }
}

/// The status of the Price.
#[derive(Debug, Serialize, Deserialize)]
pub enum PriceStatus {
    #[serde(rename = "tradeable")]
    Tradeable,
    #[serde(rename = "nontradeable")]
    Nontradeable,
    #[serde(rename = "invalid")]
    Invalid,
}

impl FromStr for PriceStatus {
    type Err = ();
    fn from_str(s: &str) -> Result<PriceStatus, ()> {
        match s {
            "tradeable" => Ok(PriceStatus::Tradeable),
            "nontradeable" => Ok(PriceStatus::Nontradeable),
            "invalid" => Ok(PriceStatus::Invalid),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for PriceStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HomeConversions {
    /// The currency to be converted into the home currency.
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    #[serde(default)]
    #[serde(rename = "currency", skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,

    /// The factor used to convert any gains for an Account in the specified
    /// currency into the Account's home currency. This would include positive
    /// realized P/L and positive financing amounts. Conversion is performed
    /// by multiplying the positive P/L by the conversion factor.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "accountGain",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub account_gain: Option<f32>,

    /// The string representation of a decimal number.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "accountLoss",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub account_loss: Option<f32>,

    /// The factor used to convert a Position or Trade Value in the specified
    /// currency into the Account's home currency. Conversion is performed by
    /// multiplying the Position or Trade Value by the conversion factor.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "positionValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub position_value: Option<f32>,
}

impl HomeConversions {
    pub fn new() -> HomeConversions {
        HomeConversions {
            currency: None,
            account_gain: None,
            account_loss: None,
            position_value: None,
        }
    }

    /// The currency to be converted into the home currency.
    /// format: A string containing an ISO 4217 currency
    /// (<https://en.wikipedia.org/wiki/ISO_4217>)
    /// - param String
    /// - return HomeConversions
    pub fn with_currency(mut self, x: String) -> Self {
        self.currency = Some(x);
        self
    }

    /// The factor used to convert any gains for an Account in the specified
    /// currency into the Account's home currency. This would include positive
    /// realized P/L and positive financing amounts. Conversion is performed
    /// by multiplying the positive P/L by the conversion factor.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return HomeConversions
    pub fn with_account_gain(mut self, x: f32) -> Self {
        self.account_gain = Some(x);
        self
    }

    /// The string representation of a decimal number.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return HomeConversions
    pub fn with_account_loss(mut self, x: f32) -> Self {
        self.account_loss = Some(x);
        self
    }

    /// The factor used to convert a Position or Trade Value in the specified
    /// currency into the Account's home currency. Conversion is performed by
    /// multiplying the Position or Trade Value by the conversion factor.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return HomeConversions
    pub fn with_position_value(mut self, x: f32) -> Self {
        self.position_value = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PricingHeartbeat {
    /// The string "HEARTBEAT"
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The date/time when the Heartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "time",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub time: Option<DateTime<Utc>>,
}

impl PricingHeartbeat {
    pub fn new() -> PricingHeartbeat {
        PricingHeartbeat {
            otype: None,
            time: None,
        }
    }

    /// The string "HEARTBEAT"
    /// - param String
    /// - return PricingHeartbeat
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The date/time when the Heartbeat was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return PricingHeartbeat
    pub fn with_time(mut self, x: DateTime<Utc>) -> Self {
        self.time = Some(x);
        self
    }
}

/// The type of the Order.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl FromStr for OrderType {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderType, ()> {
        match s {
            "MARKET" => Ok(OrderType::Market),
            "LIMIT" => Ok(OrderType::Limit),
            "STOP" => Ok(OrderType::Stop),
            "MARKET_IF_TOUCHED" => Ok(OrderType::MarketIfTouched),
            "TAKE_PROFIT" => Ok(OrderType::TakeProfit),
            "STOP_LOSS" => Ok(OrderType::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(OrderType::TrailingStopLoss),
            "FIXED_PRICE" => Ok(OrderType::FixedPrice),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The type of the Order.
#[derive(Debug, Serialize, Deserialize)]
pub enum CancellableOrderType {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
}

impl FromStr for CancellableOrderType {
    type Err = ();
    fn from_str(s: &str) -> Result<CancellableOrderType, ()> {
        match s {
            "LIMIT" => Ok(CancellableOrderType::Limit),
            "STOP" => Ok(CancellableOrderType::Stop),
            "MARKET_IF_TOUCHED" => Ok(CancellableOrderType::MarketIfTouched),
            "TAKE_PROFIT" => Ok(CancellableOrderType::TakeProfit),
            "STOP_LOSS" => Ok(CancellableOrderType::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(CancellableOrderType::TrailingStopLoss),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for CancellableOrderType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The current state of the Order.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl FromStr for OrderState {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderState, ()> {
        match s {
            "PENDING" => Ok(OrderState::Pending),
            "FILLED" => Ok(OrderState::Filled),
            "TRIGGERED" => Ok(OrderState::Triggered),
            "CANCELLED" => Ok(OrderState::Cancelled),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderState {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// The state to filter the requested Orders by.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderStateFilter {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "ALL")]
    All,
}

impl FromStr for OrderStateFilter {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderStateFilter, ()> {
        match s {
            "PENDING" => Ok(OrderStateFilter::Pending),
            "FILLED" => Ok(OrderStateFilter::Filled),
            "TRIGGERED" => Ok(OrderStateFilter::Triggered),
            "CANCELLED" => Ok(OrderStateFilter::Cancelled),
            "ALL" => Ok(OrderStateFilter::All),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderStateFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderIdentifier {
    /// The OANDA-assigned Order ID
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "orderID", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,

    /// The client-provided client Order ID
    #[serde(default)]
    #[serde(rename = "clientOrderID", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<String>,
}

impl OrderIdentifier {
    pub fn new() -> OrderIdentifier {
        OrderIdentifier {
            order_id: None,
            client_order_id: None,
        }
    }

    /// The OANDA-assigned Order ID
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return OrderIdentifier
    pub fn with_order_id(mut self, x: String) -> Self {
        self.order_id = Some(x);
        self
    }

    /// The client-provided client Order ID
    /// - param String
    /// - return OrderIdentifier
    pub fn with_client_order_id(mut self, x: String) -> Self {
        self.client_order_id = Some(x);
        self
    }
}

/// The time-in-force of an Order. TimeInForce describes how long an Order
/// should remain pending before being automatically cancelled by the
/// execution system.
#[derive(Debug, Serialize, Deserialize)]
pub enum TimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl FromStr for TimeInForce {
    type Err = ();
    fn from_str(s: &str) -> Result<TimeInForce, ()> {
        match s {
            "GTC" => Ok(TimeInForce::Gtc),
            "GTD" => Ok(TimeInForce::Gtd),
            "GFD" => Ok(TimeInForce::Gfd),
            "FOK" => Ok(TimeInForce::Fok),
            "IOC" => Ok(TimeInForce::Ioc),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for TimeInForce {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// Specification of how Positions in the Account are modified when the
/// Order is filled.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl FromStr for OrderPositionFill {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderPositionFill, ()> {
        match s {
            "OPEN_ONLY" => Ok(OrderPositionFill::OpenOnly),
            "REDUCE_FIRST" => Ok(OrderPositionFill::ReduceFirst),
            "REDUCE_ONLY" => Ok(OrderPositionFill::ReduceOnly),
            "DEFAULT" => Ok(OrderPositionFill::Default),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderPositionFill {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API. Clients
/// who choose to specify a non-default trigger condition will not see it
/// reflected in any of OANDA's proprietary or partner trading platforms,
/// their transaction history or their account statements. OANDA platforms
/// always assume that an Order's trigger condition is set to the default
/// value when indicating the distance from an Order's trigger price, and
/// will always provide the default trigger condition when creating or
/// modifying an Order. A special restriction applies when creating a
/// guaranteed Stop Loss Order. In this case the TriggerCondition value
/// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
/// valid.
#[derive(Debug, Serialize, Deserialize)]
pub enum OrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl FromStr for OrderTriggerCondition {
    type Err = ();
    fn from_str(s: &str) -> Result<OrderTriggerCondition, ()> {
        match s {
            "DEFAULT" => Ok(OrderTriggerCondition::Default),
            "INVERSE" => Ok(OrderTriggerCondition::Inverse),
            "BID" => Ok(OrderTriggerCondition::Bid),
            "ASK" => Ok(OrderTriggerCondition::Ask),
            "MID" => Ok(OrderTriggerCondition::Mid),
            _ => Err(()),
        }
    }
}

impl std::fmt::Display for OrderTriggerCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DynamicOrderState {
    /// The Order's ID.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The Order's calculated trailing stop value.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "trailingStopValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub trailing_stop_value: Option<f32>,

    /// The distance between the Trailing Stop Loss Order's trailingStopValue
    /// and the current Market Price. This represents the distance (in price
    /// units) of the Order from a triggering price. If the distance could not
    /// be determined, this value will not be set.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "triggerDistance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub trigger_distance: Option<f32>,

    /// True if an exact trigger distance could be calculated. If false, it
    /// means the provided trigger distance is a best estimate. If the
    /// distance could not be determined, this value will not be set.
    #[serde(default)]
    #[serde(
        rename = "isTriggerDistanceExact",
        skip_serializing_if = "Option::is_none"
    )]
    pub is_trigger_distance_exact: Option<bool>,
}

impl DynamicOrderState {
    pub fn new() -> DynamicOrderState {
        DynamicOrderState {
            id: None,
            trailing_stop_value: None,
            trigger_distance: None,
            is_trigger_distance_exact: None,
        }
    }

    /// The Order's ID.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return DynamicOrderState
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The Order's calculated trailing stop value.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return DynamicOrderState
    pub fn with_trailing_stop_value(mut self, x: f32) -> Self {
        self.trailing_stop_value = Some(x);
        self
    }

    /// The distance between the Trailing Stop Loss Order's trailingStopValue
    /// and the current Market Price. This represents the distance (in price
    /// units) of the Order from a triggering price. If the distance could not
    /// be determined, this value will not be set.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return DynamicOrderState
    pub fn with_trigger_distance(mut self, x: f32) -> Self {
        self.trigger_distance = Some(x);
        self
    }

    /// True if an exact trigger distance could be calculated. If false, it
    /// means the provided trigger distance is a best estimate. If the
    /// distance could not be determined, this value will not be set.
    /// - param bool
    /// - return DynamicOrderState
    pub fn with_is_trigger_distance_exact(mut self, x: bool) -> Self {
        self.is_trigger_distance_exact = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Order {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl Order {
    pub fn new() -> Order {
        Order {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return Order
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Order
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return Order
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return Order
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "MARKET" for Market Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    #[serde(default)]
    #[serde(rename = "tradeClose", skip_serializing_if = "Option::is_none")]
    pub trade_close: Option<MarketOrderTradeClose>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "longPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    #[serde(default)]
    #[serde(
        rename = "shortPositionCloseout",
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    #[serde(default)]
    #[serde(rename = "marginCloseout", skip_serializing_if = "Option::is_none")]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    #[serde(default)]
    #[serde(rename = "delayedTradeClose", skip_serializing_if = "Option::is_none")]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,
}

impl MarketOrder {
    pub fn new() -> MarketOrder {
        MarketOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            instrument: None,
            units: None,
            time_in_force: None,
            price_bound: None,
            position_fill: None,
            trade_close: None,
            long_position_closeout: None,
            short_position_closeout: None,
            margin_closeout: None,
            delayed_trade_close: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return MarketOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "MARKET" for Market Orders.
    /// - param String
    /// - return MarketOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketOrder
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketOrder
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    /// - param String
    /// - return MarketOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketOrder
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketOrder
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// A MarketOrderTradeClose specifies the extensions to a Market Order
    /// that has been created specifically to close a Trade.
    /// - param MarketOrderTradeClose
    /// - return MarketOrder
    pub fn with_trade_close(mut self, x: MarketOrderTradeClose) -> Self {
        self.trade_close = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrder
    pub fn with_long_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.long_position_closeout = Some(x);
        self
    }

    /// A MarketOrderPositionCloseout specifies the extensions to a Market
    /// Order when it has been created to closeout a specific Position.
    /// - param MarketOrderPositionCloseout
    /// - return MarketOrder
    pub fn with_short_position_closeout(mut self, x: MarketOrderPositionCloseout) -> Self {
        self.short_position_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed that is part of a Market Order Margin Closeout in a client's
    /// account
    /// - param MarketOrderMarginCloseout
    /// - return MarketOrder
    pub fn with_margin_closeout(mut self, x: MarketOrderMarginCloseout) -> Self {
        self.margin_closeout = Some(x);
        self
    }

    /// Details for the Market Order extensions specific to a Market Order
    /// placed with the intent of fully closing a specific open trade that
    /// should have already been closed but wasn't due to halted market
    /// conditions
    /// - param MarketOrderDelayedTradeClose
    /// - return MarketOrder
    pub fn with_delayed_trade_close(mut self, x: MarketOrderDelayedTradeClose) -> Self {
        self.delayed_trade_close = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketOrder
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketOrder
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketOrder
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrder
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return MarketOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FixedPriceOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "FIXED_PRICE" for Fixed Price
    /// Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Fixed Price Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Fixed Price Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price specified for the Fixed Price Order. This price is the exact
    /// price that the Fixed Price Order will be filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    #[serde(default)]
    #[serde(rename = "tradeState", skip_serializing_if = "Option::is_none")]
    pub trade_state: Option<String>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,
}

impl FixedPriceOrder {
    pub fn new() -> FixedPriceOrder {
        FixedPriceOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            position_fill: None,
            trade_state: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return FixedPriceOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return FixedPriceOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "FIXED_PRICE" for Fixed Price
    /// Orders.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Fixed Price Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Fixed Price Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return FixedPriceOrder
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price specified for the Fixed Price Order. This price is the exact
    /// price that the Fixed Price Order will be filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return FixedPriceOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_trade_state(mut self, x: String) -> Self {
        self.trade_state = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return FixedPriceOrder
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return FixedPriceOrder
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return FixedPriceOrder
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return FixedPriceOrder
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return FixedPriceOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return FixedPriceOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return FixedPriceOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return FixedPriceOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LimitOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "LIMIT" for Limit Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the Limit Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl LimitOrder {
    pub fn new() -> LimitOrder {
        LimitOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return LimitOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return LimitOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "LIMIT" for Limit Orders.
    /// - param String
    /// - return LimitOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return LimitOrder
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LimitOrder
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return LimitOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the Limit Order.
    /// - param String
    /// - return LimitOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return LimitOrder
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return LimitOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return LimitOrder
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return LimitOrder
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return LimitOrder
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrder
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return LimitOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return LimitOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return LimitOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return LimitOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return LimitOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return LimitOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "STOP" for Stop Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the Stop Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl StopOrder {
    pub fn new() -> StopOrder {
        StopOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return StopOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "STOP" for Stop Orders.
    /// - param String
    /// - return StopOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return StopOrder
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopOrder
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrder
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the Stop Order.
    /// - param String
    /// - return StopOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return StopOrder
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return StopOrder
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return StopOrder
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return StopOrder
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrder
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return StopOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketIfTouchedOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "MARKET_IF_TOUCHED" for Market If
    /// Touched Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The Market price at the time when the MarketIfTouched Order was
    /// created.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "initialMarketPrice",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub initial_market_price: Option<f32>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl MarketIfTouchedOrder {
    pub fn new() -> MarketIfTouchedOrder {
        MarketIfTouchedOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            initial_market_price: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "MARKET_IF_TOUCHED" for Market If
    /// Touched Orders.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketIfTouchedOrder
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrder
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The Market price at the time when the MarketIfTouched Order was
    /// created.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrder
    pub fn with_initial_market_price(mut self, x: f32) -> Self {
        self.initial_market_price = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketIfTouchedOrder
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketIfTouchedOrder
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketIfTouchedOrder
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrder
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return MarketIfTouchedOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return MarketIfTouchedOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TakeProfitOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "TAKE_PROFIT" for Take Profit
    /// Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl TakeProfitOrder {
    pub fn new() -> TakeProfitOrder {
        TakeProfitOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TakeProfitOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "TAKE_PROFIT" for Take Profit
    /// Orders.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TakeProfitOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return TakeProfitOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TakeProfitOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopLossOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "STOP_LOSS" for Stop Loss Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The premium that will be charged if the Stop Loss Order is guaranteed
    /// and the Order is filled at the guaranteed price. It is in price units
    /// and is charged for each unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "guaranteedExecutionPremium",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub guaranteed_execution_premium: Option<f32>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    #[serde(default)]
    #[serde(rename = "guaranteed", skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl StopLossOrder {
    pub fn new() -> StopLossOrder {
        StopLossOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            guaranteed_execution_premium: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            guaranteed: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopLossOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return StopLossOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopLossOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "STOP_LOSS" for Stop Loss Orders.
    /// - param String
    /// - return StopLossOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The premium that will be charged if the Stop Loss Order is guaranteed
    /// and the Order is filled at the guaranteed price. It is in price units
    /// and is charged for each unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrder
    pub fn with_guaranteed_execution_premium(mut self, x: f32) -> Self {
        self.guaranteed_execution_premium = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrder
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return StopLossOrder
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopLossOrder
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrder
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    /// - param String
    /// - return StopLossOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopLossOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    /// - param bool
    /// - return StopLossOrder
    pub fn with_guaranteed(mut self, x: bool) -> Self {
        self.guaranteed = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return StopLossOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return StopLossOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopLossOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return StopLossOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrailingStopLossOrder {
    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "createTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub create_time: Option<DateTime<Utc>>,

    /// The current state of the Order.
    #[serde(default)]
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// The type of the Order. Always set to "TRAILING_STOP_LOSS" for Trailing
    /// Stop Loss Orders.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// The trigger price for the Trailing Stop Loss Order. The trailing stop
    /// value will trail (follow) the market price by the TSL order's
    /// configured "distance" as the market price moves in the winning
    /// direction. If the market price moves to a level that is equal to or
    /// worse than the trailing stop value, the order will be filled and the
    /// Trade will be closed.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "trailingStopValue",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub trailing_stop_value: Option<f32>,

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "fillingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "filledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub filled_time: Option<DateTime<Utc>>,

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeOpenedID", skip_serializing_if = "Option::is_none")]
    pub trade_opened_id: Option<String>,

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeReducedID", skip_serializing_if = "Option::is_none")]
    pub trade_reduced_id: Option<String>,

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    #[serde(default)]
    #[serde(rename = "tradeClosedIDs", skip_serializing_if = "Option::is_none")]
    pub trade_closed_i_ds: Option<Vec<String>>,

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    #[serde(default)]
    #[serde(
        rename = "cancellingTransactionID",
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "cancelledTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub cancelled_time: Option<DateTime<Utc>>,

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacesOrderID", skip_serializing_if = "Option::is_none")]
    pub replaces_order_id: Option<String>,

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    #[serde(default)]
    #[serde(rename = "replacedByOrderID", skip_serializing_if = "Option::is_none")]
    pub replaced_by_order_id: Option<String>,
}

impl TrailingStopLossOrder {
    pub fn new() -> TrailingStopLossOrder {
        TrailingStopLossOrder {
            id: None,
            create_time: None,
            state: None,
            client_extensions: None,
            otype: None,
            trade_id: None,
            client_trade_id: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            trailing_stop_value: None,
            filling_transaction_id: None,
            filled_time: None,
            trade_opened_id: None,
            trade_reduced_id: None,
            trade_closed_i_ds: None,
            cancelling_transaction_id: None,
            cancelled_time: None,
            replaces_order_id: None,
            replaced_by_order_id: None,
        }
    }

    /// The Order's identifier, unique within the Order's Account.
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_id(mut self, x: String) -> Self {
        self.id = Some(x);
        self
    }

    /// The time when the Order was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrder
    pub fn with_create_time(mut self, x: DateTime<Utc>) -> Self {
        self.create_time = Some(x);
        self
    }

    /// The current state of the Order.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_state(mut self, x: String) -> Self {
        self.state = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TrailingStopLossOrder
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// The type of the Order. Always set to "TRAILING_STOP_LOSS" for Trailing
    /// Stop Loss Orders.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TrailingStopLossOrder
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrder
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// The trigger price for the Trailing Stop Loss Order. The trailing stop
    /// value will trail (follow) the market price by the TSL order's
    /// configured "distance" as the market price moves in the winning
    /// direction. If the market price moves to a level that is equal to or
    /// worse than the trailing stop value, the order will be filled and the
    /// Trade will be closed.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TrailingStopLossOrder
    pub fn with_trailing_stop_value(mut self, x: f32) -> Self {
        self.trailing_stop_value = Some(x);
        self
    }

    /// ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_filling_transaction_id(mut self, x: String) -> Self {
        self.filling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrder
    pub fn with_filled_time(mut self, x: DateTime<Utc>) -> Self {
        self.filled_time = Some(x);
        self
    }

    /// Trade ID of Trade opened when the Order was filled (only provided when
    /// the Order's state is FILLED and a Trade was opened as a result of the
    /// fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_trade_opened_id(mut self, x: String) -> Self {
        self.trade_opened_id = Some(x);
        self
    }

    /// Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_trade_reduced_id(mut self, x: String) -> Self {
        self.trade_reduced_id = Some(x);
        self
    }

    /// Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed as
    /// a result of the fill)
    /// - param Vec<String>
    /// - return TrailingStopLossOrder
    pub fn with_trade_closed_i_ds(mut self, x: Vec<String>) -> Self {
        self.trade_closed_i_ds = Some(x);
        self
    }

    /// ID of the Transaction that cancelled the Order (only provided when the
    /// Order's state is CANCELLED)
    /// format: String representation of the numerical OANDA-assigned TransactionID
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_cancelling_transaction_id(mut self, x: String) -> Self {
        self.cancelling_transaction_id = Some(x);
        self
    }

    /// Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrder
    pub fn with_cancelled_time(mut self, x: DateTime<Utc>) -> Self {
        self.cancelled_time = Some(x);
        self
    }

    /// The ID of the Order that was replaced by this Order (only provided if
    /// this Order was created as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_replaces_order_id(mut self, x: String) -> Self {
        self.replaces_order_id = Some(x);
        self
    }

    /// The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    /// format: The string representation of the OANDA-assigned OrderID. OANDA-
    /// assigned OrderIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that created the Order.
    /// - param String
    /// - return TrailingStopLossOrder
    pub fn with_replaced_by_order_id(mut self, x: String) -> Self {
        self.replaced_by_order_id = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderRequest {}

impl OrderRequest {
    pub fn new() -> OrderRequest {
        OrderRequest {}
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketOrderRequest {
    /// The type of the Order to Create. Must be set to "MARKET" when creating
    /// a Market Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl MarketOrderRequest {
    pub fn new() -> MarketOrderRequest {
        MarketOrderRequest {
            otype: None,
            instrument: None,
            units: None,
            time_in_force: None,
            price_bound: None,
            position_fill: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "MARKET" when creating
    /// a Market Order.
    /// - param String
    /// - return MarketOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Market Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketOrderRequest
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Market Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketOrderRequest
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The time-in-force requested for the Market Order. Restricted to FOK or
    /// IOC for a MarketOrder.
    /// - param String
    /// - return MarketOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The worst price that the client is willing to have the Market Order
    /// filled at.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketOrderRequest
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketOrderRequest
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketOrderRequest
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketOrderRequest
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketOrderRequest
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketOrderRequest
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LimitOrderRequest {
    /// The type of the Order to Create. Must be set to "LIMIT" when creating
    /// a Market Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the Limit Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl LimitOrderRequest {
    pub fn new() -> LimitOrderRequest {
        LimitOrderRequest {
            otype: None,
            instrument: None,
            units: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "LIMIT" when creating
    /// a Market Order.
    /// - param String
    /// - return LimitOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Limit Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return LimitOrderRequest
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Limit Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return LimitOrderRequest
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better than
    /// this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return LimitOrderRequest
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the Limit Order.
    /// - param String
    /// - return LimitOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return LimitOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return LimitOrderRequest
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return LimitOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return LimitOrderRequest
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return LimitOrderRequest
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return LimitOrderRequest
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return LimitOrderRequest
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopOrderRequest {
    /// The type of the Order to Create. Must be set to "STOP" when creating a
    /// Stop Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the Stop Order.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl StopOrderRequest {
    pub fn new() -> StopOrderRequest {
        StopOrderRequest {
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "STOP" when creating a
    /// Stop Order.
    /// - param String
    /// - return StopOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The Stop Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return StopOrderRequest
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the Stop Order. A positive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopOrderRequest
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the Stop Order. The Stop Order will
    /// only be filled by a market price that is equal to or worse than this
    /// price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderRequest
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the priceBound,
    /// the Stop Order will be cancelled instead of being filled.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopOrderRequest
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the Stop Order.
    /// - param String
    /// - return StopOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the Stop Order will be cancelled if its timeInForce
    /// is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return StopOrderRequest
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return StopOrderRequest
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return StopOrderRequest
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return StopOrderRequest
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopOrderRequest
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarketIfTouchedOrderRequest {
    /// The type of the Order to Create. Must be set to "MARKET_IF_TOUCHED"
    /// when creating a Market If Touched Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "units",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub units: Option<f32>,

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "priceBound",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price_bound: Option<f32>,

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(default)]
    #[serde(rename = "positionFill", skip_serializing_if = "Option::is_none")]
    pub position_fill: Option<String>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "takeProfitOnFill", skip_serializing_if = "Option::is_none")]
    pub take_profit_on_fill: Option<TakeProfitDetails>,

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    #[serde(default)]
    #[serde(rename = "stopLossOnFill", skip_serializing_if = "Option::is_none")]
    pub stop_loss_on_fill: Option<StopLossDetails>,

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    #[serde(default)]
    #[serde(
        rename = "trailingStopLossOnFill",
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(
        rename = "tradeClientExtensions",
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl MarketIfTouchedOrderRequest {
    pub fn new() -> MarketIfTouchedOrderRequest {
        MarketIfTouchedOrderRequest {
            otype: None,
            instrument: None,
            units: None,
            price: None,
            price_bound: None,
            time_in_force: None,
            gtd_time: None,
            position_fill: None,
            trigger_condition: None,
            client_extensions: None,
            take_profit_on_fill: None,
            stop_loss_on_fill: None,
            trailing_stop_loss_on_fill: None,
            trade_client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "MARKET_IF_TOUCHED"
    /// when creating a Market If Touched Order.
    /// - param String
    /// - return MarketIfTouchedOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The MarketIfTouched Order's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return MarketIfTouchedOrderRequest
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// The quantity requested to be filled by the MarketIfTouched Order. A
    /// positive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return MarketIfTouchedOrderRequest
    pub fn with_units(mut self, x: f32) -> Self {
        self.units = Some(x);
        self
    }

    /// The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the time
    /// when the Order was created (the initialMarketPrice). Depending on the
    /// value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderRequest
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return MarketIfTouchedOrderRequest
    pub fn with_price_bound(mut self, x: f32) -> Self {
        self.price_bound = Some(x);
        self
    }

    /// The time-in-force requested for the MarketIfTouched Order. Restricted
    /// to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    /// - param String
    /// - return MarketIfTouchedOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the MarketIfTouched Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return MarketIfTouchedOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of how Positions in the Account are modified when the
    /// Order is filled.
    /// - param String
    /// - return MarketIfTouchedOrderRequest
    pub fn with_position_fill(mut self, x: String) -> Self {
        self.position_fill = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return MarketIfTouchedOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }

    /// TakeProfitDetails specifies the details of a Take Profit Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Take Profit, or when a Trade's
    /// dependent Take Profit Order is modified directly through the Trade.
    /// - param TakeProfitDetails
    /// - return MarketIfTouchedOrderRequest
    pub fn with_take_profit_on_fill(mut self, x: TakeProfitDetails) -> Self {
        self.take_profit_on_fill = Some(x);
        self
    }

    /// StopLossDetails specifies the details of a Stop Loss Order to be
    /// created on behalf of a client. This may happen when an Order is filled
    /// that opens a Trade requiring a Stop Loss, or when a Trade's dependent
    /// Stop Loss Order is modified directly through the Trade.
    /// - param StopLossDetails
    /// - return MarketIfTouchedOrderRequest
    pub fn with_stop_loss_on_fill(mut self, x: StopLossDetails) -> Self {
        self.stop_loss_on_fill = Some(x);
        self
    }

    /// TrailingStopLossDetails specifies the details of a Trailing Stop Loss
    /// Order to be created on behalf of a client. This may happen when an
    /// Order is filled that opens a Trade requiring a Trailing Stop Loss, or
    /// when a Trade's dependent Trailing Stop Loss Order is modified directly
    /// through the Trade.
    /// - param TrailingStopLossDetails
    /// - return MarketIfTouchedOrderRequest
    pub fn with_trailing_stop_loss_on_fill(mut self, x: TrailingStopLossDetails) -> Self {
        self.trailing_stop_loss_on_fill = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return MarketIfTouchedOrderRequest
    pub fn with_trade_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.trade_client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TakeProfitOrderRequest {
    /// The type of the Order to Create. Must be set to "TAKE_PROFIT" when
    /// creating a Take Profit Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl TakeProfitOrderRequest {
    pub fn new() -> TakeProfitOrderRequest {
        TakeProfitOrderRequest {
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "TAKE_PROFIT" when
    /// creating a Take Profit Order.
    /// - param String
    /// - return TakeProfitOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TakeProfitOrderRequest
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TakeProfitOrderRequest
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the TakeProfit Order. The associated
    /// Trade will be closed by a market price that is equal to or better than
    /// this threshold.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return TakeProfitOrderRequest
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    /// - param String
    /// - return TakeProfitOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TakeProfitOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TakeProfitOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TakeProfitOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StopLossOrderRequest {
    /// The type of the Order to Create. Must be set to "STOP_LOSS" when
    /// creating a Stop Loss Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    #[serde(default)]
    #[serde(rename = "guaranteed", skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl StopLossOrderRequest {
    pub fn new() -> StopLossOrderRequest {
        StopLossOrderRequest {
            otype: None,
            trade_id: None,
            client_trade_id: None,
            price: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            guaranteed: None,
            client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "STOP_LOSS" when
    /// creating a Stop Loss Order.
    /// - param String
    /// - return StopLossOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return StopLossOrderRequest
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return StopLossOrderRequest
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return StopLossOrderRequest
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return StopLossOrderRequest
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    /// - param String
    /// - return StopLossOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return StopLossOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return StopLossOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if it
    /// is REQUIRED, the default will be true, for DISABLED or ENABLED the
    /// default is false.
    /// - param bool
    /// - return StopLossOrderRequest
    pub fn with_guaranteed(mut self, x: bool) -> Self {
        self.guaranteed = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return StopLossOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrailingStopLossOrderRequest {
    /// The type of the Order to Create. Must be set to "TRAILING_STOP_LOSS"
    /// when creating a Trailing Stop Loss Order.
    #[serde(default)]
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub otype: Option<String>,

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    #[serde(default)]
    #[serde(rename = "tradeID", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(default)]
    #[serde(rename = "clientTradeID", skip_serializing_if = "Option::is_none")]
    pub client_trade_id: Option<String>,

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "distance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub distance: Option<f32>,

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(default)]
    #[serde(rename = "timeInForce", skip_serializing_if = "Option::is_none")]
    pub time_in_force: Option<String>,

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "gtdTime",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub gtd_time: Option<DateTime<Utc>>,

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    #[serde(default)]
    #[serde(rename = "triggerCondition", skip_serializing_if = "Option::is_none")]
    pub trigger_condition: Option<String>,

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    #[serde(default)]
    #[serde(rename = "clientExtensions", skip_serializing_if = "Option::is_none")]
    pub client_extensions: Option<ClientExtensions>,
}

impl TrailingStopLossOrderRequest {
    pub fn new() -> TrailingStopLossOrderRequest {
        TrailingStopLossOrderRequest {
            otype: None,
            trade_id: None,
            client_trade_id: None,
            distance: None,
            time_in_force: None,
            gtd_time: None,
            trigger_condition: None,
            client_extensions: None,
        }
    }

    /// The type of the Order to Create. Must be set to "TRAILING_STOP_LOSS"
    /// when creating a Trailing Stop Loss Order.
    /// - param String
    /// - return TrailingStopLossOrderRequest
    pub fn with_otype(mut self, x: String) -> Self {
        self.otype = Some(x);
        self
    }

    /// The ID of the Trade to close when the price threshold is breached.
    /// format: The string representation of the OANDA-assigned TradeID. OANDA-
    /// assigned TradeIDs are positive integers, and are derived from the
    /// TransactionID of the Transaction that opened the Trade.
    /// - param String
    /// - return TrailingStopLossOrderRequest
    pub fn with_trade_id(mut self, x: String) -> Self {
        self.trade_id = Some(x);
        self
    }

    /// The client ID of the Trade to be closed when the price threshold is
    /// breached.
    /// - param String
    /// - return TrailingStopLossOrderRequest
    pub fn with_client_trade_id(mut self, x: String) -> Self {
        self.client_trade_id = Some(x);
        self
    }

    /// The price distance (in price units) specified for the TrailingStopLoss
    /// Order.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return TrailingStopLossOrderRequest
    pub fn with_distance(mut self, x: f32) -> Self {
        self.distance = Some(x);
        self
    }

    /// The time-in-force requested for the TrailingStopLoss Order. Restricted
    /// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    /// - param String
    /// - return TrailingStopLossOrderRequest
    pub fn with_time_in_force(mut self, x: String) -> Self {
        self.time_in_force = Some(x);
        self
    }

    /// The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return TrailingStopLossOrderRequest
    pub fn with_gtd_time(mut self, x: DateTime<Utc>) -> Self {
        self.gtd_time = Some(x);
        self
    }

    /// Specification of which price component should be used when determining
    /// if an Order should be triggered and filled. This allows Orders to be
    /// triggered based on the bid, ask, mid, default (ask for buy, bid for
    /// sell) or inverse (ask for sell, bid for buy) price depending on the
    /// desired behaviour. Orders are always filled using their default price
    /// component. This feature is only provided through the REST API. Clients
    /// who choose to specify a non-default trigger condition will not see it
    /// reflected in any of OANDA's proprietary or partner trading platforms,
    /// their transaction history or their account statements. OANDA platforms
    /// always assume that an Order's trigger condition is set to the default
    /// value when indicating the distance from an Order's trigger price, and
    /// will always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when creating a
    /// guaranteed Stop Loss Order. In this case the TriggerCondition value
    /// must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
    /// results in. So for a Stop Loss Order for a long trade valid values are
    /// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are
    /// valid.
    /// - param String
    /// - return TrailingStopLossOrderRequest
    pub fn with_trigger_condition(mut self, x: String) -> Self {
        self.trigger_condition = Some(x);
        self
    }

    /// A ClientExtensions object allows a client to attach a clientID, tag
    /// and comment to Orders and Trades in their Account.  Do not set,
    /// modify, or delete this field if your account is associated with MT4.
    /// - param ClientExtensions
    /// - return TrailingStopLossOrderRequest
    pub fn with_client_extensions(mut self, x: ClientExtensions) -> Self {
        self.client_extensions = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UnitsAvailableDetails {
    /// The units available for long Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "long",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub long: Option<f32>,

    /// The units available for short Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "short",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub short: Option<f32>,
}

impl UnitsAvailableDetails {
    pub fn new() -> UnitsAvailableDetails {
        UnitsAvailableDetails {
            long: None,
            short: None,
        }
    }

    /// The units available for long Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return UnitsAvailableDetails
    pub fn with_long(mut self, x: f32) -> Self {
        self.long = Some(x);
        self
    }

    /// The units available for short Orders.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return UnitsAvailableDetails
    pub fn with_short(mut self, x: f32) -> Self {
        self.short = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GuaranteedStopLossOrderEntryData {
    /// The minimum distance allowed between the Trade's fill price and the
    /// configured price for guaranteed Stop Loss Orders created for this
    /// instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "minimumDistance",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub minimum_distance: Option<f32>,

    /// The amount that is charged to the account if a guaranteed Stop Loss
    /// Order is triggered and filled. The value is in price units and is
    /// charged for each unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    #[serde(default)]
    #[serde(
        rename = "premium",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub premium: Option<f32>,

    /// A GuaranteedStopLossOrderLevelRestriction represents the total
    /// position size that can exist within a given price window for Trades
    /// with guaranteed Stop Loss Orders attached for a specific Instrument.
    #[serde(default)]
    #[serde(rename = "levelRestriction", skip_serializing_if = "Option::is_none")]
    pub level_restriction: Option<GuaranteedStopLossOrderLevelRestriction>,
}

impl GuaranteedStopLossOrderEntryData {
    pub fn new() -> GuaranteedStopLossOrderEntryData {
        GuaranteedStopLossOrderEntryData {
            minimum_distance: None,
            premium: None,
            level_restriction: None,
        }
    }

    /// The minimum distance allowed between the Trade's fill price and the
    /// configured price for guaranteed Stop Loss Orders created for this
    /// instrument. Specified in price units.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return GuaranteedStopLossOrderEntryData
    pub fn with_minimum_distance(mut self, x: f32) -> Self {
        self.minimum_distance = Some(x);
        self
    }

    /// The amount that is charged to the account if a guaranteed Stop Loss
    /// Order is triggered and filled. The value is in price units and is
    /// charged for each unit of the Trade.
    /// format: A decimal number encoded as a string. The amount of precision provided
    /// depends on what the number represents.
    /// - param f32
    /// - return GuaranteedStopLossOrderEntryData
    pub fn with_premium(mut self, x: f32) -> Self {
        self.premium = Some(x);
        self
    }

    /// A GuaranteedStopLossOrderLevelRestriction represents the total
    /// position size that can exist within a given price window for Trades
    /// with guaranteed Stop Loss Orders attached for a specific Instrument.
    /// - param GuaranteedStopLossOrderLevelRestriction
    /// - return GuaranteedStopLossOrderEntryData
    pub fn with_level_restriction(mut self, x: GuaranteedStopLossOrderLevelRestriction) -> Self {
        self.level_restriction = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PriceBucket {
    /// The Price offered by the PriceBucket
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "price",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub price: Option<f32>,

    /// The amount of liquidity offered by the PriceBucket
    #[serde(default)]
    #[serde(rename = "liquidity", skip_serializing_if = "Option::is_none")]
    pub liquidity: Option<i32>,
}

impl PriceBucket {
    pub fn new() -> PriceBucket {
        PriceBucket {
            price: None,
            liquidity: None,
        }
    }

    /// The Price offered by the PriceBucket
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return PriceBucket
    pub fn with_price(mut self, x: f32) -> Self {
        self.price = Some(x);
        self
    }

    /// The amount of liquidity offered by the PriceBucket
    /// - param i32
    /// - return PriceBucket
    pub fn with_liquidity(mut self, x: i32) -> Self {
        self.liquidity = Some(x);
        self
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Price {
    /// The Price's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    #[serde(default)]
    #[serde(rename = "instrument", skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,

    /// Flag indicating if the Price is tradeable or not
    #[serde(default)]
    #[serde(rename = "tradeable", skip_serializing_if = "Option::is_none")]
    pub tradeable: Option<bool>,

    /// The date/time when the Price was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    #[serde(default)]
    #[serde(
        rename = "timestamp",
        skip_serializing_if = "Option::is_none",
        with = "serdates"
    )]
    pub timestamp: Option<DateTime<Utc>>,

    /// The base bid price as calculated by pricing.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "baseBid",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub base_bid: Option<f32>,

    /// The base ask price as calculated by pricing.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "baseAsk",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub base_ask: Option<f32>,

    /// The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default)]
    #[serde(rename = "bids", skip_serializing_if = "Option::is_none")]
    pub bids: Option<Vec<PriceBucket>>,

    /// The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default)]
    #[serde(rename = "asks", skip_serializing_if = "Option::is_none")]
    pub asks: Option<Vec<PriceBucket>>,

    /// The closeout bid price. This price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "closeoutBid",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub closeout_bid: Option<f32>,

    /// The closeout ask price. This price is used when an ask is required to
    /// closeout a Position (margin closeout or manual) yet there is no ask
    /// liquidity. The closeout ask is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    #[serde(default)]
    #[serde(
        rename = "closeoutAsk",
        skip_serializing_if = "Option::is_none",
        with = "serfloats"
    )]
    pub closeout_ask: Option<f32>,
}

impl Price {
    pub fn new() -> Price {
        Price {
            instrument: None,
            tradeable: None,
            timestamp: None,
            base_bid: None,
            base_ask: None,
            bids: None,
            asks: None,
            closeout_bid: None,
            closeout_ask: None,
        }
    }

    /// The Price's Instrument.
    /// format: A string containing the base currency and quote currency delimited by
    /// a "_".
    /// - param String
    /// - return Price
    pub fn with_instrument(mut self, x: String) -> Self {
        self.instrument = Some(x);
        self
    }

    /// Flag indicating if the Price is tradeable or not
    /// - param bool
    /// - return Price
    pub fn with_tradeable(mut self, x: bool) -> Self {
        self.tradeable = Some(x);
        self
    }

    /// The date/time when the Price was created.
    /// format: The RFC 3339 representation is a string conforming to
    /// <https://tools.ietf.org/rfc/rfc3339.txt> The Unix representation is a
    /// string representing the number of seconds since the Unix Epoch
    /// (January 1st, 1970 at UTC). The value is a fractional number, where
    /// the fractional part represents a fraction of a second (up to nine
    /// decimal places).
    /// - param DateTime<Utc>
    /// - return Price
    pub fn with_timestamp(mut self, x: DateTime<Utc>) -> Self {
        self.timestamp = Some(x);
        self
    }

    /// The base bid price as calculated by pricing.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Price
    pub fn with_base_bid(mut self, x: f32) -> Self {
        self.base_bid = Some(x);
        self
    }

    /// The base ask price as calculated by pricing.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Price
    pub fn with_base_ask(mut self, x: f32) -> Self {
        self.base_ask = Some(x);
        self
    }

    /// The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    /// - param Vec<PriceBucket>
    /// - return Price
    pub fn with_bids(mut self, x: Vec<PriceBucket>) -> Self {
        self.bids = Some(x);
        self
    }

    /// The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    /// - param Vec<PriceBucket>
    /// - return Price
    pub fn with_asks(mut self, x: Vec<PriceBucket>) -> Self {
        self.asks = Some(x);
        self
    }

    /// The closeout bid price. This price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Price
    pub fn with_closeout_bid(mut self, x: f32) -> Self {
        self.closeout_bid = Some(x);
        self
    }

    /// The closeout ask price. This price is used when an ask is required to
    /// closeout a Position (margin closeout or manual) yet there is no ask
    /// liquidity. The closeout ask is never used to open a new position.
    /// format: A decimal number encodes as a string. The amount of precision provided
    /// depends on the Instrument.
    /// - param f32
    /// - return Price
    pub fn with_closeout_ask(mut self, x: f32) -> Self {
        self.closeout_ask = Some(x);
        self
    }
}
